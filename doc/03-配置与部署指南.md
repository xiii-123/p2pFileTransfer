# 配置与部署指南

## 环境配置

### 开发环境

#### 1. 安装 Go

**下载和安装**:
```bash
# Linux/macOS
wget https://go.dev/dl/go1.23.8.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.23.8.linux-amd64.tar.gz

# 设置环境变量
export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/go
```

**验证安装**:
```bash
go version
# 输出: go version go1.23.8 linux/amd64
```

#### 2. 克隆项目

```bash
git clone https://github.com/yourusername/p2pFileTransfer.git
cd p2pFileTransfer
```

#### 3. 安装依赖

```bash
# 下载所有依赖
go mod download

# 验证依赖
go mod verify
```

#### 4. 配置开发环境

```bash
# 复制配置文件
cp config/config.example.yaml config/config.yaml

# 编辑配置
vim config/config.yaml
```

**开发环境推荐配置** (`config.dev.yaml`):
```yaml
network:
  insecure: true        # 使用不安全连接便于调试
  port: 8000            # 固定端口

logging:
  level: "debug"        # 详细日志
  format: "text"        # 文本格式便于阅读

performance:
  max_concurrency: 8    # 降低并发
```

#### 5. 运行开发服务器

```bash
# 方式1: 直接运行
go run cmd/server/main.go

# 方式2: 使用配置文件
go run cmd/server/main.go -config config/config.dev.yaml

# 方式3: 使用环境变量
P2P_PORT=8000 P2P_LOG_LEVEL=debug go run cmd/server/main.go
```

#### 6. 运行测试

```bash
# 运行所有测试
go test ./test -v

# 运行特定测试
go test ./test -v -run TestMultiNode

# 运行快速测试（跳过多节点）
go test ./test -v -short
```

### 生产环境

#### 1. 系统要求

**操作系统**:
- Linux (推荐 Ubuntu 20.04+ 或 CentOS 8+)
- macOS 10.15+
- Windows Server 2019+

**硬件要求**:
- CPU: 4 核心以上
- 内存: 4GB 以上
- 磁盘: 根据存储需求（建议 100GB+）
- 网络: 公网 IP 或端口映射

**网络要求**:
- 开放 TCP 端口（默认随机，可配置）
- 防火墙允许入站连接
- 如需 NAT 穿透，配置 UPnP 或端口转发

#### 2. 编译生产版本

```bash
# Linux
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-linux-amd64 ./cmd/p2p
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-server-linux-amd64 ./cmd/server

# macOS
GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-darwin-amd64 ./cmd/p2p

# Windows
GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-windows-amd64.exe ./cmd/p2p

# ARM64 (树莓派等)
GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bin/p2p-linux-arm64 ./cmd/p2p
```

#### 3. 创建生产配置

**生产环境配置** (`config.prod.yaml`):
```yaml
network:
  port: 0               # 随机端口（推荐）
  insecure: false       # 必须使用安全连接
  bootstrap_peers:      # 指定引导节点
    - /ip4/1.2.3.4/tcp/8001/p2p/QmPeerID1
    - /ip4/5.6.7.8/tcp/8001/p2p/QmPeerID2

storage:
  chunk_path: "/var/lib/p2p/chunks"  # 使用绝对路径
  block_size: 262144                 # 256KB

performance:
  max_concurrency: 32   # 高并发
  max_retries: 3
  request_timeout: 10
  data_timeout: 60
  dht_timeout: 20

logging:
  level: "info"         # 生产环境使用 info
  format: "json"        # JSON 格式便于日志收集

anti_leecher:
  enabled: true
  min_success_rate: 0.6
  min_requests: 20
```

#### 4. 部署方案

##### 方案 A: 直接部署

```bash
# 1. 上传二进制文件
scp bin/p2p-server-linux-amd64 user@server:/usr/local/bin/p2p-server
scp config.prod.yaml user@server:/etc/p2p/config.yaml

# 2. 创建用户和目录
ssh user@server
sudo useradd -r -s /bin/false p2p
sudo mkdir -p /var/lib/p2p/chunks
sudo mkdir -p /var/lib/p2p/metadata
sudo chown -R p2p:p2p /var/lib/p2p

# 3. 创建 systemd 服务
sudo vim /etc/systemd/system/p2p.service
```

**Systemd 服务文件** (`/etc/systemd/system/p2p.service`):
```ini
[Unit]
Description=P2P File Transfer Service
After=network.target

[Service]
Type=simple
User=p2p
Group=p2p
ExecStart=/usr/local/bin/p2p-server -config /etc/p2p/config.yaml
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

# 环境变量
Environment="P2P_LOG_LEVEL=info"

# 资源限制
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```

**启动服务**:
```bash
# 重载 systemd
sudo systemctl daemon-reload

# 启用并启动
sudo systemctl enable p2p
sudo systemctl start p2p

# 查看状态
sudo systemctl status p2p

# 查看日志
sudo journalctl -u p2p -f
```

##### 方案 B: Docker 部署

**Dockerfile**:
```dockerfile
FROM golang:1.23-alpine AS builder

WORKDIR /app
COPY . .
RUN go mod download
RUN go build -ldflags="-s -w" -o p2p-server ./cmd/server

FROM alpine:latest

RUN apk add --no-cache ca-certificates tzdata

WORKDIR /app

COPY --from=builder /app/p2p-server /app/p2p-server
COPY config/config.prod.yaml /app/config.yaml

# 创建目录
RUN mkdir -p /app/files /app/metadata

EXPOSE 4001

ENTRYPOINT ["/app/p2p-server"]
CMD ["-config", "/app/config.yaml"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  p2p:
    build: .
    container_name: p2p-server
    restart: unless-stopped
    ports:
      - "4001:4001"  # libp2p 默认端口
      - "8000:8000"  # 自定义端口
    volumes:
      - ./data:/app/files
      - ./metadata:/app/metadata
      - ./config.prod.yaml:/app/config.yaml:ro
    environment:
      - P2P_LOG_LEVEL=info
      - P2P_PORT=8000
    networks:
      - p2p-network

networks:
  p2p-network:
    driver: bridge
```

**部署**:
```bash
# 构建镜像
docker-compose build

# 启动服务
docker-compose up -d

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

##### 方案 C: Kubernetes 部署

**Deployment** (`p2p-deployment.yaml`):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: p2p-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: p2p
  template:
    metadata:
      labels:
        app: p2p
    spec:
      containers:
      - name: p2p-server
        image: your-registry/p2p-server:latest
        ports:
        - containerPort: 4001
        - containerPort: 8000
        env:
        - name: P2P_LOG_LEVEL
          value: "info"
        - name: P2P_PORT
          value: "0"
        volumeMounts:
        - name: storage
          mountPath: /app/files
        - name: metadata
          mountPath: /app/metadata
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: p2p-storage
      - name: metadata
        persistentVolumeClaim:
          claimName: p2p-metadata
```

**Service** (`p2p-service.yaml`):
```yaml
apiVersion: v1
kind: Service
metadata:
  name: p2p-service
spec:
  selector:
    app: p2p
  ports:
  - name: libp2p
    port: 4001
    targetPort: 4001
  - name: custom
    port: 8000
    targetPort: 8000
  type: LoadBalancer
```

**部署**:
```bash
kubectl apply -f p2p-deployment.yaml
kubectl apply -f p2p-service.yaml

# 查看 Pod 状态
kubectl get pods -l app=p2p

# 查看日志
kubectl logs -l app=p2p --tail=100 -f
```

## 配置文件解析

### 主配置文件

**位置**: `config/config.yaml`

**完整配置示例**:
```yaml
# ========== 网络配置 ==========
network:
  # 监听端口 (0 = 随机分配)
  port: 0

  # 是否使用不安全连接（仅开发环境）
  insecure: false

  # 随机种子（用于确定性密钥生成）
  seed: 0

  # Bootstrap 节点地址
  bootstrap_peers: []

  # 协议前缀
  protocol_prefix: "/p2p-file-transfer"

  # 启用自动刷新
  auto_refresh: true

  # DHT 命名空间
  namespace: "p2p-file-transfer"

# ========== 存储配置 ==========
storage:
  # Chunk 存储路径
  chunk_path: "files"

  # Merkle 树块大小（字节）
  block_size: 262144  # 256KB

  # 缓冲区数量
  buffer_number: 16

# ========== 性能配置 ==========
performance:
  # 最大重试次数
  max_retries: 3

  # 最大并发下载数
  max_concurrency: 16

  # 请求超时（秒）
  request_timeout: 5

  # 数据传输超时（秒）
  data_timeout: 30

  # DHT 操作超时（秒）
  dht_timeout: 10

# ========== 日志配置 ==========
logging:
  # 日志级别 (debug, info, warn, error)
  level: "info"

  # 日志格式 (json, text)
  format: "text"

# ========== HTTP API 配置 ==========
http:
  # HTTP 服务器端口
  port: 8080

  # 元数据存储路径
  metadata_path: "metadata"

# ========== 反吸血虫配置 ==========
anti_leecher:
  # 是否启用反吸血虫机制
  enabled: true

  # 最小成功率阈值（0.0-1.0）
  min_success_rate: 0.5

  # 黑名单前的最小请求数
  min_requests: 10
```

### 关键配置项

| 配置项 | 默认值 | 说明 | 修改影响 |
|--------|--------|------|----------|
| **network.port** | 0 | 监听端口，0表示随机 | 指定端口可能导致端口占用 |
| **network.insecure** | false | 不安全连接 | ⚠️ 生产环境必须为false |
| **storage.chunk_path** | "files" | Chunk存储路径 | 修改后需确保目录存在且有写权限 |
| **storage.block_size** | 262144 | 分块大小（字节） | 影响传输效率和内存使用 |
| **performance.max_concurrency** | 16 | 最大并发数 | 过高可能耗尽资源，过低影响性能 |
| **performance.max_retries** | 3 | 最大重试次数 | 影响失败恢复能力 |
| **logging.level** | "info" | 日志级别 | debug会产生大量日志 |
| **anti_leecher.enabled** | true | 反吸血虫开关 | 关闭后可能被滥用 |

### 配置文件搜索路径

**搜索顺序**（从高到低）:
1. 命令行 `-config` 参数指定的路径
2. `./config.yaml`
3. `./config/config.yaml`
4. `/etc/p2p-file-transfer/config.yaml`

**代码**:
```go
// pkg/config/loader.go
func GetConfigPath(customPath string) string {
    if customPath != "" {
        return customPath
    }

    paths := []string{
        "./config.yaml",
        "./config/config.yaml",
        "/etc/p2p-file-transfer/config.yaml",
    }

    for _, path := range paths {
        if _, err := os.Stat(path); err == nil {
            return path
        }
    }

    return ""  // 使用默认配置
}
```

## 配置优先级

**优先级**（从高到低）:
```
1. 命令行参数
   ↓
2. 环境变量 (P2P_*)
   ↓
3. 配置文件
   ↓
4. 代码默认值
```

**示例**:
```bash
# 最终端口为 9000 (命令行参数最高)
p2p-server -port 9000

# 最终端口为 8000 (环境变量次之)
P2P_PORT=8000 p2p-server

# 最终端口为 7000 (配置文件)
# config.yaml: port: 7000
p2p-server

# 最终端口为 0 (代码默认值)
p2p-server
```

## 环境变量

### 完整列表

| 环境变量 | 对应配置项 | 示例值 | 说明 |
|---------|-----------|--------|------|
| `P2P_PORT` | network.port | `8000` | 监听端口 |
| `P2P_INSECURE` | network.insecure | `true` | 不安全连接 |
| `P2P_SEED` | network.seed | `12345` | 随机种子 |
| `P2P_BOOTSTRAP_PEERS` | network.bootstrap_peers | `/ip4/...` | 引导节点（逗号分隔） |
| `P2P_PROTOCOL_PREFIX` | network.protocol_prefix | `/p2p` | 协议前缀 |
| `P2P_NAMESPACE` | network.namespace | `p2p` | DHT命名空间 |
| `P2P_CHUNK_PATH` | storage.chunk_path | `/data/chunks` | Chunk存储路径 |
| `P2P_BLOCK_SIZE` | storage.block_size | `262144` | 分块大小 |
| `P2P_BUFFER_NUMBER` | storage.buffer_number | `16` | 缓冲区数量 |
| `P2P_MAX_RETRIES` | performance.max_retries | `3` | 最大重试次数 |
| `P2P_MAX_CONCURRENCY` | performance.max_concurrency | `16` | 最大并发数 |
| `P2P_REQUEST_TIMEOUT` | performance.request_timeout | `5` | 请求超时（秒） |
| `P2P_DATA_TIMEOUT` | performance.data_timeout | `30` | 数据超时（秒） |
| `P2P_DHT_TIMEOUT` | performance.dht_timeout | `10` | DHT超时（秒） |
| `P2P_LOG_LEVEL` | logging.level | `info` | 日志级别 |
| `P2P_LOG_FORMAT` | logging.format | `json` | 日志格式 |
| `P2P_HTTP_PORT` | http.port | `8080` | HTTP服务器端口 |
| `P2P_METADATA_PATH` | http.metadata_path | `metadata` | 元数据存储路径 |
| `P2P_ANTI_LEECHER_ENABLED` | anti_leecher.enabled | `true` | 反吸血虫开关 |
| `P2P_MIN_SUCCESS_RATE` | anti_leecher.min_success_rate | `0.5` | 最小成功率 |
| `P2P_MIN_REQUESTS` | anti_leecher.min_requests | `10` | 最小请求数 |

### 使用示例

```bash
# 使用环境变量覆盖配置
export P2P_PORT=8000
export P2P_LOG_LEVEL=debug
export P2P_MAX_CONCURRENCY=32

p2p-server

# 或者一行命令
P2P_PORT=8000 P2P_LOG_LEVEL=debug P2P_MAX_CONCURRENCY=32 p2p-server
```

## 配置验证

### 自动验证

系统会自动验证配置，包括：

- **端口范围**: 0-65535
- **块大小**: 1KB - 4MB
- **并发数**: 1 - 1024
- **超时时间**: 1 - 7200 秒
- **成功率阈值**: 0.0 - 1.0
- **日志级别**: debug, info, warn, error
- **日志格式**: json, text

**示例错误**:
```
config validation failed: invalid port: 70000 (must be 0-65535)
```

### 手动验证

```bash
# 使用 CLI 验证配置
./bin/p2p config validate config/config.yaml

# 输出:
# ✓ Configuration file is valid
```

## 配置最佳实践

### 1. 分环境配置

```bash
config/
├── config.dev.yaml       # 开发环境
├── config.test.yaml      # 测试环境
├── config.staging.yaml   # 预发布环境
└── config.prod.yaml      # 生产环境
```

### 2. 敏感信息使用环境变量

```yaml
# config.yaml
network:
  # 不在配置文件中写入敏感信息
  bootstrap_peers: []

storage:
  chunk_path: "/data/chunks"
```

```bash
# 使用环境变量传入敏感配置
export P2P_BOOTSTRAP_PEERS="/ip4/...,..."
```

### 3. 使用 .env 文件（开发环境）

**.env**:
```bash
P2P_PORT=8000
P2P_LOG_LEVEL=debug
P2P_MAX_CONCURRENCY=8
```

**加载**:
```bash
# 使用 direnv
source .env

# 或手动
export $(cat .env | xargs)
```

## 部署后检查

### 1. 检查服务状态

```bash
# Systemd
sudo systemctl status p2p

# Docker
docker ps | grep p2p

# Kubernetes
kubectl get pods -l app=p2p
```

### 2. 检查日志

```bash
# Systemd
sudo journalctl -u p2p -n 100

# Docker
docker logs p2p-server --tail 100

# Kubernetes
kubectl logs -l app=p2p --tail 100
```

### 3. 检查网络连接

```bash
# 查看监听端口
sudo netstat -tlnp | grep p2p

# 或使用 ss
sudo ss -tlnp | grep p2p

# 输出示例:
# tcp  0  0  0.0.0.0:8000  0.0.0.0:*  LISTEN  12345/p2p-server
```

### 4. 检查 P2P 连接

```bash
# 使用 CLI 检查连接的节点
./bin/p2p peer list

# 输出:
# Connected Peers: 5
# - QmPeerID1 (/ip4/1.2.3.4/tcp/8001)
# - QmPeerID2 (/ip4/5.6.7.8/tcp/8001)
# ...
```

## 性能调优

### 1. 并发调优

```yaml
performance:
  max_concurrency: 32   # 根据带宽和CPU调整
```

**建议值**:
- 家庭网络: 8-16
- 数据中心: 32-64
- 高性能服务器: 64-128

### 2. 超时调优

```yaml
performance:
  request_timeout: 10    # 慢速网络增加
  data_timeout: 60       # 大文件下载增加
  dht_timeout: 20        # 大型网络增加
```

### 3. 内存调优

```yaml
storage:
  buffer_number: 32      # 增加缓冲区
```

### 4. 日志调优

```yaml
logging:
  level: "warn"          # 生产环境使用 warn
  format: "json"         # 便于日志聚合
```

## 监控和告警

### 1. 日志聚合

**使用 ELK**:
```bash
# Filebeat 配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/p2p/*.log
  json.keys_under_root: true

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
```

### 2. 指标收集

**使用 Prometheus**:
```go
// 添加 Prometheus 指标（需要集成）
import "github.com/prometheus/client_golang/prometheus"

var (
    downloadCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "p2p_downloads_total",
            Help: "Total number of downloads",
        },
        []string{"status"},
    )
)
```

### 3. 告警规则

**Prometheus 告警**:
```yaml
groups:
- name: p2p
  rules:
  - alert: P2PServiceDown
    expr: up{job="p2p"} == 0
    for: 5m
    annotations:
      summary: "P2P service is down"

  - alert: P2PHighFailureRate
    expr: rate(p2p_downloads_total{status="failed"}[5m]) > 0.1
    annotations:
      summary: "High download failure rate"
```

---

**下一步**: 阅读 [组件文档/](组件文档/) 了解各组件详情
