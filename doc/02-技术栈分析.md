# 技术栈分析

## 核心技术栈

| 类别 | 技术/工具 | 版本 | 用途 | 替代方案 |
|------|-----------|------|------|----------|
| **语言** | Go | 1.23+ | 主要开发语言 | Rust, C++, Java |
| **P2P 框架** | libp2p | v0.41.1 | 点对点网络实现 | go-BitTorrent, 自建 |
| **DHT 实现** | go-libp2p-kad-dht | v0.31.0 | Kademlia 分布式哈希表 | 自建 DHT, 其他 KAD 实现 |
| **HTTP 框架** | net/http | 标准库 | HTTP REST API 服务器 | Gin, Echo, Fiber |
| **多地址** | go-multiaddr | v0.15.0 | 自寻址格式 | 传统地址格式 |
| **日志** | logrus | v1.9.3 | 结构化日志 | zap, zero-logging |
| **配置** | viper | v1.21.0 | 配置管理 | env, yaml.v3 |
| **CLI 框架** | cobra | v1.10.2 | 命令行界面 | cli, urfave/cli |
| **测试** | testify | v1.11.1 | 测试框架 | testing, ginkgo |
| **加密** | elliptic | 标准库 | 椭圆曲线密码学 | ecdsa, 第三方库 |
| **哈希** | crypto/sha256 | 标准库 | SHA256 哈希 | blake3, sha3 |

## 核心依赖分析

### 1. libp2p (v0.41.1)

**项目**: [libp2p/go-libp2p](https://github.com/libp2p/go-libp2p)

**用途**: P2P 网络的基石，提供节点发现、连接管理、数据传输等功能

**主要功能**:
- 节点身份管理（Peer ID）
- 传输协议（TCP, WebSocket, QUIC）
- NAT 穿透
- 流 multiplexing
- 加密通信（Noise Protocol）
- 协议 multiplexing

**使用场景**:
```go
import (
    "github.com/libp2p/go-libp2p"
    "github.com/libp2p/go-libp2p/core/host"
)

func newBasicHost(port int, insecure bool, seed int64) (host.Host, error) {
    opts := []libp2p.Option{
        libp2p.ListenAddrStrings(fmt.Sprintf("/ip4/0.0.0.0/tcp/%d", port)),
    }

    if insecure {
        opts = append(opts, libp2p.NoSecurity)
    }

    return libp2p.New(opts...)
}
```

**依赖的子包**:
- `go-libp2p-core`: 核心接口定义
- `go-libp2p-transport`: 传输层实现
- `go-libp2p-noise`: 加密协议
- `go-libp2p-yamux`: 流多路复用

**版本兼容性**:
- ✅ Go 1.19+
- ✅ Linux, macOS, Windows
- ✅ ARM64, AMD64

**潜在问题**:
- 学习曲线陡峭
- 文档分散在多个仓库
- 某些功能需要深度定制

**替代方案**:
| 方案 | 优势 | 劣势 |
|------|------|------|
| **自建 P2P** | 完全控制，轻量 | 开发成本高，功能有限 |
| **go-BitTorrent** | 成熟，文档好 | 仅支持 BitTorrent 协议 |
| **WebRTC** | 浏览器支持 | 需要信令服务器 |

### 2. go-libp2p-kad-dht (v0.31.0)

**项目**: [libp2p/go-libp2p-kad-dht](https://github.com/libp2p/go-libp2p-kad-dht)

**用途**: Kademlia DHT 实现，用于内容路由和节点发现

**主要功能**:
- PutValue/GetValue: 键值对存储
- FindProviders: 查找内容提供者
- Provide: 公告内容可用性
- Bootstrap: 网络引导

**使用示例**:
```go
import (
    dht "github.com/libp2p/go-libp2p-kad-dht"
    "github.com/libp2p/go-libp2p/p2p/net/swarm"
)

func newDHT(ctx context.Context, host host.Host, config P2PConfig) (*dht.IpfsDHT, error) {
    return dht.New(ctx, host,
        dht.Mode(dht.ModeAutoServer),
        dht.ProtocolPrefix(config.ProtocolPrefix),
        dht.Validator(config.Validator),
        dht.NamespacedValidator(config.NameSpace, config.Validator),
    )
}
```

**Kademlia 特性**:
- XOR 距离度量
- 二叉树路由表（K-bucket）
- 并行查询
- 自动刷新

**配置选项**:
| 参数 | 默认值 | 说明 |
|------|--------|------|
| Mode | ModeAutoServer | 工作模式 |
| ProtocolPrefix | /default | 协议前缀 |
| Namespace | v | 命名空间 |
| BucketSize | 20 | K-bucket 大小 |
| Concurrency | 10 | 并发查询数 |

**替代方案**:
| 方案 | 优势 | 劣势 |
|------|------|------|
| **Chord** | 简单 | 效率较低 |
| **Pastry** | 负载均衡好 | 实现复杂 |
| **自建 DHT** | 完全控制 | 稳定性未知 |

### 3. go-multiaddr (v0.15.0)

**项目**: [multiformats/go-multiaddr](https://github.com/multiformats/go-multiaddr)

**用途**: 自描述的地址格式，支持多种协议

**格式示例**:
```
/ip4/127.0.0.1/tcp/8000/p2p/QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N
```

**优势**:
- 自描述，无需解析
- 支持协议嵌套
- 跨语言兼容
- 人类可读

**使用示例**:
```go
import "github.com/multiformats/go-multiaddr"

// 解析地址
addr, _ := multiaddr.NewMultiaddr("/ip4/127.0.0.1/tcp/8000")

// 提取组件
protocols := addr.Protocols()
for _, p := range protocols {
    fmt.Printf("%s: %s\n", p.Name, p.Value)
}
```

**协议组件**:
- `/ip4/<IPv4>`: IPv4 地址
- `/ip6/<IPv6>`: IPv6 地址
- `/tcp/<port>`: TCP 端口
- `/p2p/<peer-id>`: libp2p 节点 ID
- `/ws`: WebSocket
- `/dns/<domain>`: DNS 地址

**替代方案**: 传统 `host:port` 格式

### 4. net/http (Go 标准库)

**包**: `net/http`

**用途**: HTTP REST API 服务器

**主要功能**:
- HTTP 服务器实现
- 路由处理（ServeMux）
- 请求/响应处理
- CORS 支持
- Multipart 文件上传
- JSON 响应

**使用示例**:
```go
import "net/http"

// 创建服务器
server := &http.Server{
    Addr:    ":8080",
    Handler: mux,
}

// 注册路由
mux.HandleFunc("/api/health", handleHealth)
mux.HandleFunc("/api/v1/files/upload", handleFileUpload)

// 启动服务器
server.ListenAndServe()
```

**API 端点**:
- `GET /api/health` - 健康检查
- `POST /api/v1/files/upload` - 文件上传
- `GET /api/v1/files/{cid}` - 文件信息
- `GET /api/v1/files/{cid}/download` - 文件下载
- `GET /api/v1/node/info` - 节点信息
- `GET /api/v1/node/peers` - 对等节点列表
- `POST /api/v1/dht/announce` - DHT 公告
- `GET /api/v1/dht/value/{key}` - DHT 获取值
- `POST /api/v1/dht/value` - DHT 存储值
- `GET /api/v1/dht/providers/{key}` - DHT 查找提供者

**优势**:
- ✅ 标准库，无额外依赖
- ✅ 性能优异
- ✅ 稳定可靠
- ✅ 跨平台支持

**替代方案**:
| 方案 | 优势 | 劣势 |
|------|------|------|
| **Gin** | 功能丰富，高性能 | 需要额外依赖 |
| **Echo** | 轻量，中间件多 | 学习曲线 |
| **Fiber** | 极快 | 基于 fasthttp，不兼容 |

### 5. logrus (v1.9.3)

**项目**: [sirupsen/logrus](https://github.com/sirupsen/logrus)

**用途**: 结构化日志记录

**主要功能**:
- 结构化日志（JSON 格式）
- 日志级别（Debug, Info, Warn, Error）
- 钩子机制（Hooks）
- 自定义格式化

**使用示例**:
```go
import "github.com/sirupsen/logrus"

// 配置日志
logrus.SetLevel(logrus.DebugLevel)
logrus.SetFormatter(&logrus.JSONFormatter{})

// 记录日志
logrus.WithFields(logrus.Fields{
    "peer": peerID,
    "chunk": chunkHash,
}).Info("Downloaded chunk")
```

**配置**:
| 选项 | 值 |
|------|-----|
| Level | info/debug/warn/error |
| Format | json/text |
| Output | stdout/file |

**替代方案**:
| 方案 | 性能 | 特性 |
|------|------|------|
| **zap** | 极快 | 零分配 |
| **zero-logging** | 快 | 简单 |
| **标准库** | 慢 | 基础 |

### 5. viper (v1.21.0)

**项目**: [spf13/viper](https://github.com/spf13/viper)

**用途**: 配置管理，支持多种配置源

**主要功能**:
- 多格式支持（JSON, YAML, TOML, HCL）
- 环境变量读取
- 命令行参数绑定
- 默认值设置
- 配置监听（热重载）

**使用示例**:
```go
import "github.com/spf13/viper"

viper.SetConfigName("config")
viper.SetConfigType("yaml")
viper.AddConfigPath("./config")
viper.ReadInConfig()

// 读取配置
port := viper.GetInt("network.port")
insecure := viper.GetBool("network.insecure")

// 环境变量
viper.BindEnv("port", "P2P_PORT")
viper.AutomaticEnv()
```

**优先级**:
1. 命令行参数
2. 环境变量
3. 配置文件
4. 默认值

**替代方案**:
| 方案 | 优势 | 劣势 |
|------|------|------|
| **env** | 简单 | 仅环境变量 |
| **yaml.v3** | 轻量 | 功能有限 |
| **自建** | 灵活 | 开发成本 |

### 6. cobra (v1.10.2)

**项目**: [spf13/cobra](https://github.com/spf13/cobra)

**用途**: CLI 应用框架

**主要功能**:
- 子命令嵌套
- 参数验证
- 自动生成帮助
- 自动补全
- 别名支持

**使用示例**:
```go
import "github.com/spf13/cobra"

var rootCmd = &cobra.Command{
    Use:   "p2p",
    Short: "P2P File Transfer CLI",
}

var uploadCmd = &cobra.Command{
    Use:   "upload <file>",
    Short: "Upload a file",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        // 上传逻辑
    },
}

uploadCmd.Flags().StringP("type", "t", "chameleon", "Merkle tree type")
rootCmd.AddCommand(uploadCmd)
```

**特性**:
- 持久标志（Persistent Flags）
- 本地标志（Local Flags）
- 必需参数验证
- 建议参数（Suggestions）

**替代方案**:
| 方案 | 优势 | 劣势 |
|------|------|------|
| **urfave/cli** | 简单 | 功能较少 |
| **cli** | 易用 | 不支持嵌套 |
| **flag** | 标准库 | 功能基础 |

### 7. testify (v1.11.1)

**项目**: [stretchr/testify](https://github.com/stretchr/testify)

**用途**: 测试框架和断言库

**主要功能**:
- 断言（Assertions）
- Mock 功能
- 测试套件（Suites）
- 跳过测试

**使用示例**:
```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
)

func TestCalculateChunkHashes(t *testing.T) {
    file, _ := os.Open("test.txt")
    chunks, err := CalculateChunkHashes(file, 1024)

    assert.NoError(t, err)
    assert.Len(t, chunks, 10)
    assert.NotNil(t, chunks[0].Hash)
}

type MySuite struct {
    suite.Suite
    service *P2PService
}

func (s *MySuite) SetupTest() {
    s.service = NewTestService()
}

func (s *MySuite) TearDownTest() {
    s.service.Shutdown()
}
```

**断言列表**:
- `assert.Equal(t, expected, actual)`
- `assert.NoError(t, err)`
- `assert.Nil(t, obj)`
- `assert.True(t, condition)`
- `assert.Contains(t, collection, element)`

**替代方案**: Go 标准库 `testing`

### 8. elliptic (标准库)

**包**: `crypto/elliptic`

**用途**: 椭圆曲线密码学

**使用场景**: Chameleon 哈希中的密钥生成和签名

**支持曲线**:
- P224
- P256 (本项目使用)
- P384
- P521

**使用示例**:
```go
import (
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
)

// 生成密钥对
curve := elliptic.P256()
privKey, err := ecdsa.GenerateKey(curve, rand.Reader)

// 签名
r, s, err := ecdsa.Sign(rand.Reader, privKey, hash)

// 验证
valid := ecdsa.Verify(&privKey.PublicKey, hash, r, s)
```

**为什么选择 P256**:
- ✅ 广泛支持
- ✅ 性能好
- ✅ 安全性高
- ✅ NIST 标准

**替代方案**:
| 曲线 | 优势 | 劣势 |
|------|------|------|
| **P25519 (ed25519)** | 更快 | 非 NIST 标准 |
| **P384** | 更安全 | 性能较差 |
| **P521** | 最高安全 | 性能差 |

## 依赖关系图

```
p2pFileTransfer
├── libp2p (v0.41.1)
│   ├── go-libp2p-core
│   ├── go-libp2p-transport
│   ├── go-libp2p-noise
│   ├── go-libp2p-yamux
│   └── go-multiaddr (v0.15.0)
│
├── go-libp2p-kad-dht (v0.31.0)
│   ├── go-libp2p-core
│   ├── go-libp2p-record
│   └── go-libp2p-kbucket
│
├── cobra (v1.10.2)
│   ├── spf13/pflag
│   └── spf13/cast
│
├── viper (v1.21.0)
│   ├── spf13/pflag
│   ├── spf13/afero
│   └── fsnotify/fsnotify
│
├── logrus (v1.9.3)
│   └── 无直接依赖
│
└── testify (v1.11.1)
    └── 无直接依赖
```

## 版本兼容性

### Go 版本

**要求**: Go 1.23+

**原因**:
- 使用了 Go 1.23 的新特性
- 依赖库要求

**测试版本**:
- ✅ Go 1.23.0
- ✅ Go 1.23.8 (推荐)
- ⚠️ Go 1.22.x (可能兼容)
- ❌ Go < 1.22 (不支持)

### 操作系统

**支持**:
- ✅ Linux (amd64, arm64)
- ✅ macOS (amd64, arm64)
- ✅ Windows (amd64)

**测试环境**:
- Ubuntu 20.04/22.04
- macOS 12/13/14
- Windows 10/11

### 架构

**支持**:
- ✅ amd64 (x86_64)
- ✅ arm64 (AArch64)

**潜在问题**:
- ARM 性能可能略低
- Windows 防火墙可能阻止连接

## 开发环境要求

### 硬件要求

**最小配置**:
- CPU: 2 核
- 内存: 2GB
- 磁盘: 100MB

**推荐配置**:
- CPU: 4 核
- 内存: 4GB
- 磁盘: 1GB

**生产环境**:
- CPU: 8 核+
- 内存: 8GB+
- 磁盘: 根据存储需求

### 软件要求

**必需**:
- Go 1.23+
- Git
- 文本编辑器（VS Code, GoLand 等）

**可选**:
- Docker (容器化部署)
- Make (构建工具)
- Graphviz (可视化依赖图)

### 环境配置

```bash
# 1. 安装 Go 1.23+
# 下载: https://golang.org/dl/

# 2. 设置环境变量
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
export GO111MODULE=on

# 3. 验证安装
go version
# 输出: go version go1.23.8 ...

# 4. 克隆项目
git clone https://github.com/yourusername/p2pFileTransfer.git
cd p2pFileTransfer

# 5. 下载依赖
go mod download

# 6. 构建
go build -o bin/p2p ./cmd/p2p
```

## 潜在依赖冲突点

### 1. libp2p 版本更新

**风险**: libp2p API 变化频繁

**缓解**:
- 固定主版本号
- 定期测试新版本
- 关注 CHANGELOG

### 2. Go 标准库变化

**风险**: crypto/elliptic 未来可能废弃

**缓解**:
- 关注 Go 发布说明
- 准备迁移到 ecdsa 包
- 代码解耦

### 3. 传递依赖冲突

**风险**: 不同包依赖同一库的不同版本

**当前状态**: ✅ 无冲突

**检查**:
```bash
go list -m all | sort
```

## 性能特性

### 内存占用

| 组件 | 内存占用 | 说明 |
|------|----------|------|
| P2PService | ~10 MB | 基础服务 |
| DHT | ~50 MB | 路由表 |
| 连接 | ~1 MB/连接 | 活跃连接 |
| Chunk 下载 | ~32 KB | 固定缓冲区 |

### CPU 使用

**空闲时**: < 1% CPU

**下载时**:
- 1 个文件: ~10% CPU
- 10 个并发文件: ~50% CPU
- 100 个并发文件: ~100% CPU

**上传时**: ~5% CPU

### 网络性能

**带宽使用**:
- 上传: 取决于上传速度
- 下载: 取决于 MaxConcurrency 配置
- DHT 维护: ~10 KB/s

**延迟**:
- 本地节点: < 10ms
- 区域内: < 100ms
- 跨区域: < 500ms

## 安全特性

### 加密算法

| 用途 | 算法 | 密钥长度 | 安全等级 |
|------|------|----------|----------|
| 文件哈希 | SHA256 | 256 位 | 高 |
| Chameleon 哈希 | ECDSA P256 | 256 位 | 高 |
| 通信加密 | Noise Protocol | 256 位 | 高 |

### 安全配置

```yaml
network:
  insecure: false  # 生产环境必须设为 false

performance:
  max_concurrency: 16  # 防止资源耗尽
```

---

**下一步**: 阅读 [03-配置与部署指南.md](03-配置与部署指南.md) 学习如何部署
