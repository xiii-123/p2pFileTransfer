# 常见问题与扩展思路

## 常见问题

### Q1: 如何解决"端口已被占用"错误？

**错误信息**:
```
failed to create host: failed to listen on port 8000: address already in use
```

**原因**:
- 指定的端口已被其他进程占用
- 之前的 P2P 服务未正确关闭

**解决方案**:

1. **查找占用端口的进程**:
```bash
# Linux/macOS
lsof -i :8000

# Windows
netstat -ano | findstr :8000
```

2. **终止进程**:
```bash
# Linux/macOS
kill -9 <PID>

# Windows
taskkill /PID <PID> /F
```

3. **使用随机端口**（推荐）:
```yaml
# config/config.yaml
network:
  port: 0  # 0 = 随机分配端口
```

4. **或者指定其他端口**:
```yaml
network:
  port: 9000
```

### Q2: DHT 无法找到其他节点？

**现象**:
```
WARN No providers found for chunk
```

**原因**:
- 网络中没有其他节点
- Bootstrap 节点配置错误
- 防火墙阻止了连接

**解决方案**:

1. **检查网络连接**:
```bash
# 测试网络连通性
ping 8.8.8.8

# 检查 DNS
nslookup google.com
```

2. **配置 Bootstrap 节点**:
```yaml
# config/config.yaml
network:
  bootstrap_peers:
    - /ip4/1.2.3.4/tcp/8001/p2p/QmPeerID1
    - /ip4/5.6.7.8/tcp/8001/p2p/QmPeerID2
```

3. **启动多个节点**:
```bash
# 终端1: 启动节点1
./bin/p2p-server

# 终端2: 启动节点2（使用节点1作为 bootstrap）
P2P_BOOTSTRAP_PEERS="/ip4/127.0.0.1/tcp/8001/p2p/QmPeerID1" ./bin/p2p-server
```

4. **检查防火墙**:
```bash
# Linux
sudo ufw allow 8000/tcp

# Windows
# 控制面板 → Windows Defender 防火墙 → 高级设置 → 入站规则 → 新建规则
```

### Q3: 文件下载很慢？

**现象**:
- 下载速度只有几 KB/s
- 下载经常超时

**原因**:
- 并发数太低
- 网络延迟高
- 节点选择策略不当
- 带宽限制

**解决方案**:

1. **增加并发数**:
```yaml
# config/config.yaml
performance:
  max_concurrency: 32  # 从 16 增加到 32
```

2. **调整超时**:
```yaml
performance:
  request_timeout: 10  # 增加请求超时
  data_timeout: 60     # 增加数据超时
```

3. **优化节点选择**:
```go
// 使用更智能的选择器
service.PeerSelector = &LatencyBasedPeerSelector{
    tracker: service.LatencyTracker,
}
```

4. **检查网络带宽**:
```bash
# 测试网速
speedtest-cli

# 或使用
curl -o /dev/null http://speedtest.tele2.net/10MB.zip
```

### Q4: 内存占用过高？

**现象**:
- 进程内存占用持续增长
- 可能存在内存泄漏

**原因**:
- Chunk 缓存未释放
- Goroutine 泄漏
- 连接未正确关闭

**解决方案**:

1. **分析内存 profile**:
```bash
# 生成 memory profile
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 分析
go tool pprof heap.prof

# 查看 top 函数
(pprof) top

# 查看详细内容
(pprof) list <function>
```

2. **检查 Goroutine 数量**:
```bash
# 查看 goroutine 数量
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# 或在代码中添加
runtime.NumGoroutine()
```

3. **确保资源释放**:
```go
// 正确使用 defer
file, err := os.Open(path)
if err != nil {
    return err
}
defer file.Close()  // ✅ 确保文件关闭

// 正确关闭连接
defer stream.Close()

// 正确取消上下文
ctx, cancel := context.WithTimeout(context.Background(), timeout)
defer cancel()  // ✅ 释放资源
```

4. **限制并发**:
```go
// 使用工作池
semaphore := make(chan struct{}, maxConcurrency)

for _, task := range tasks {
    semaphore <- struct{}{}  // 获取令牌
    go func(t Task) {
        defer func() { <-semaphore }()  // 释放令牌
        process(t)
    }(task)
}
```

### Q5: 如何验证文件完整性？

**方法1: 使用 Merkle 树验证**

```go
// 加载元数据
metadata, err := file.LoadMetadata("metadata/cid.json")
if err != nil {
    log.Fatal(err)
}

// 下载文件
err := service.DownloadFile(ctx, metadata, "downloaded.txt")
if err != nil {
    log.Fatal(err)
}

// 验证根哈希
downloadedHash := computeFileHash("downloaded.txt")
if !bytes.Equal(downloadedHash, metadata.RootHash) {
    log.Fatal("File integrity check failed!")
}
```

**方法2: 使用 CLI 验证**

```bash
# 查看文件信息
./bin/p2p file info <cid>

# 输出包含根哈希，可以手动验证
```

### Q6: Chameleon Merkle Tree 私钥丢失？

**问题**: 私钥丢失后无法修改文件

**解决方案**:

1. **预防措施**:
```bash
# 备份私钥
cp metadata/cid.key metadata/cid.key.backup

# 加密私钥
gpg --symmetric --cipher-algo AES256 metadata/cid.key
```

2. **如果私钥已丢失**:
- 无法使用 Chameleon 特性修改文件
- 但文件仍可正常下载和验证
- 考虑重新上传文件作为新版本

### Q7: 如何处理大量小文件？

**问题**: 传输大量小文件效率低

**解决方案**:

1. **打包后再传输**:
```bash
# 打包
tar -czf archive.tar.gz files/

# 上传
./bin/p2p file upload archive.tar.gz

# 下载后解压
tar -xzf archive.tar.gz
```

2. **批量上传**:
```go
// 实现批量上传功能
for _, filePath := range filePaths {
    metadata, err := service.UploadFile(ctx, filePath)
    if err != nil {
        log.Printf("Failed to upload %s: %v", filePath, err)
        continue
    }
    log.Printf("Uploaded %s: %x", filePath, metadata.RootHash)
}
```

### Q8: 如何使用 HTTP API 上传大文件？

**问题**: HTTP 上传大文件时超时或内存不足

**解决方案**:

1. **增加请求超时**:
```yaml
# config/config.yaml
performance:
  request_timeout: 3600  # 1小时
  data_timeout: 7200      # 2小时
```

2. **使用流式上传**（已实现）:
```go
// cmd/api/handlers.go 已使用流式处理
// 不会将整个文件加载到内存
```

3. **分块上传**:
```bash
# 使用 split 分割大文件
split -b 100M large_file.bin part_

# 逐个上传
for f in part_*; do
  curl -X POST http://localhost:8080/api/v1/files/upload \
    -F "file=@$f" \
    -F "tree_type=regular"
done
```

### Q9: HTTP API 返回 CORS 错误？

**问题**: 浏览器控制台显示 CORS 错误

**解决方案**:

1. **已内置 CORS 支持**:
```go
// cmd/api/server.go 已经实现了 CORS 中间件
```

2. **检查响应头**:
```bash
curl -I http://localhost:8080/api/health

# 应该看到:
# Access-Control-Allow-Origin: *
# Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
# Access-Control-Allow-Headers: Content-Type, Authorization
```

3. **前端调用示例**:
```javascript
// 使用 fetch API
fetch('http://localhost:8080/api/v1/files/upload', {
  method: 'POST',
  body: formData,
  mode: 'cors',  // 启用 CORS
})
.then(response => response.json())
.then(data => console.log(data));
```

### Q10: 如何监控 HTTP API 性能？

**方法1: 访问日志**

```yaml
# config/config.yaml
logging:
  level: "info"
  format: "json"  # JSON 格式便于解析
```

**方法2: 集成 Prometheus**

```go
// cmd/api/server.go
import "github.com/prometheus/client_golang/prometheus"

var (
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "p2p_http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
)

// 在处理器中使用
httpRequestsTotal.WithLabelValues("POST", "/api/v1/files/upload", "200").Inc()
```

### Q11: 网络中断后如何恢复？

**问题**: 网络中断导致下载失败

**解决方案**:

1. **自动重试**:
```go
// 在下载配置中增加重试次数
performance:
  max_retries: 5  # 增加重试次数
```

2. **断点续传**（需要实现）:
```go
// 记录已下载的 chunk
type DownloadState struct {
    CID         string
    Downloaded  map[int]bool
    TotalChunks int
}

// 保存状态
func (s *DownloadState) Save(path string) error {
    data, _ := json.Marshal(s)
    return os.WriteFile(path, data, 0644)
}

// 恢复下载
func (s *DownloadState) Load(path string) error {
    data, err := os.ReadFile(path)
    if err != nil {
        return err
    }
    return json.Unmarshal(data, s)
}

// 跳过已下载的 chunk
for i, chunk := range chunks {
    if state.Downloaded[i] {
        continue  // 跳过已下载的
    }
    // 下载 chunk
}
```

### Q9: 如何监控 P2P 服务？

**方法1: 使用日志**

```yaml
# config/config.yaml
logging:
  level: "info"  # 生产环境使用 info
  format: "json" # JSON 格式便于解析
```

**方法2: 集成 Prometheus**:

```go
import "github.com/prometheus/client_golang/prometheus"

var (
    downloadCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "p2p_downloads_total",
            Help: "Total number of downloads",
        },
        []string{"status"},
    )

    uploadCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "p2p_uploads_total",
            Help: "Total number of uploads",
        },
        []string{"tree_type"},
    )
)

func init() {
    prometheus.MustRegister(downloadCounter)
    prometheus.MustRegister(uploadCounter)
}

// 在代码中使用
downloadCounter.WithLabelValues("success").Inc()
```

**方法3: 暴露 metrics 端点**:

```go
import "net/http"

func startMetricsServer() {
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
}
```

### Q10: 如何升级到新版本？

**步骤**:

1. **备份数据**:
```bash
# 备份 metadata
cp -r metadata metadata.backup

# 备份配置
cp config/config.yaml config.yaml.backup
```

2. **停止服务**:
```bash
sudo systemctl stop p2p
# 或
docker-compose down
```

3. **更新代码**:
```bash
git pull origin main
```

4. **重新编译**:
```bash
go build -o bin/p2p ./cmd/p2p
go build -o bin/p2p-server ./cmd/server
```

5. **更新配置**（如有必要）:
```bash
# 查看配置变更
git diff config/config.example.yaml

# 更新配置文件
vim config/config.yaml
```

6. **启动服务**:
```bash
sudo systemctl start p2p
# 或
docker-compose up -d
```

7. **验证**:
```bash
# 查看日志
sudo journalctl -u p2p -f

# 检查版本
./bin/p2p version
```

## 性能优化建议

### 1. 瓶颈分析

**工具**:
- `pprof` - CPU 和内存分析
- `trace` - 执行追踪
- `go-torch` - 火焰图

**步骤**:
1. 生成 profile
2. 分析热点函数
3. 优化关键路径
4. 验证改进效果

### 2. 优化策略

#### 优化1: 减少内存分配

**Before**:
```go
func processChunks(chunks [][]byte) {
    for _, chunk := range chunks {
        // 每次循环都创建新的 buffer
        buffer := make([]byte, len(chunk))
        copy(buffer, chunk)
        process(buffer)
    }
}
```

**After**:
```go
func processChunks(chunks [][]byte) {
    // 复用 buffer
    buffer := make([]byte, 0, 1024*1024)  // 1MB 容量
    for _, chunk := range chunks {
        buffer = buffer[:0]  // 重置长度
        buffer = append(buffer, chunk...)
        process(buffer)
    }
}
```

#### 优化2: 并行处理

**Before**:
```go
for i := 0; i < len(tasks); i++ {
    process(tasks[i])  // 串行处理
}
```

**After**:
```go
var wg sync.WaitGroup
semaphore := make(chan struct{}, runtime.NumCPU())

for i := 0; i < len(tasks); i++ {
    wg.Add(1)
    semaphore <- struct{}{}

    go func(index int) {
        defer wg.Done()
        defer func() { <-semaphore }()

        process(tasks[index])
    }(i)
}

wg.Wait()
```

#### 优化3: 缓存结果

```go
type Cache struct {
    data map[string][]byte
    mu   sync.RWMutex
    ttl  time.Duration
}

func (c *Cache) Get(key string) ([]byte, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    data, exists := c.data[key]
    return data, exists
}

func (c *Cache) Set(key string, value []byte) {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.data[key] = value

    // 自动过期
    go func() {
        time.Sleep(c.ttl)
        c.mu.Lock()
        delete(c.data, key)
        c.mu.Unlock()
    }()
}
```

### 3. 监控指标

**关键指标**:
- 下载速度（MB/s）
- 上传速度（MB/s）
- 连接数
- Goroutine 数量
- 内存使用
- CPU 使用
- 错误率

**工具**:
- Prometheus + Grafana
- ELK Stack（日志）
- Jaeger（追踪）

## 扩展思路

### 功能扩展

#### 1. 文件搜索功能

**需求**: 在 P2P 网络中搜索文件

**实现思路**:

```go
// 1. 定义文件索引
type FileIndex struct {
    FileName  string
    CID       string
    Keywords  []string
    Size      int64
    UploadTime time.Time
}

// 2. 发布文件索引
func (p *P2PService) PublishIndex(index FileIndex) error {
    data, _ := json.Marshal(index)
    key := "index:" + index.FileName
    return p.DHT.PutValue(p.Ctx, key, data)
}

// 3. 搜索文件
func (p *P2PService) SearchFiles(keyword string) ([]FileIndex, error) {
    // 通过 DHT 搜索
    // ...
}
```

#### 2. 文件版本控制

**需求**: 跟踪文件的多个版本

**实现思路**:

```go
// 1. 定义版本信息
type FileVersion struct {
    CID        string
    Version    int
    ParentCID  string  // 父版本 CID
    Message    string  // 提交消息
    Timestamp  time.Time
}

// 2. 版本链
type VersionChain struct {
    Current *FileVersion
    History []*FileVersion
}

// 3. 操作
func (vc *VersionChain) AddVersion(cid string, message string) {
    newVersion := &FileVersion{
        CID:       cid,
        Version:   vc.Current.Version + 1,
        ParentCID: vc.Current.CID,
        Message:   message,
        Timestamp: time.Now(),
    }
    vc.History = append(vc.History, vc.Current)
    vc.Current = newVersion
}
```

#### 3. 文件共享权限控制

**需求**: 控制谁可以访问特定文件

**实现思路**:

```go
// 1. 访问控制列表
type AccessControl struct {
    CID       string
    Owner     peer.ID
    Readers   []peer.ID  // 允许读取的节点
    Writers   []peer.ID  // 允许写入的节点
}

// 2. 检查权限
func (ac *AccessControl) CanRead(requester peer.ID) bool {
    if requester == ac.Owner {
        return true
    }
    for _, reader := range ac.Readers {
        if reader == requester {
            return true
        }
    }
    return false
}

// 3. 在传输前验证
func (p *P2PService) GetChunkWithAuth(
    ctx context.Context,
    peerID peer.ID,
    chunkHash []byte,
    ac *AccessControl,
) ([]byte, error) {
    if !ac.CanRead(peerID) {
        return nil, xerrors.Errorf("access denied")
    }

    return p.GetChunkData(ctx, peerID, chunkHash)
}
```

#### 4. 文件加密存储

**需求**: 加密存储敏感文件

**实现思路**:

```go
// 1. 加密工具
type EncryptionTool interface {
    Encrypt(data []byte, key []byte) ([]byte, error)
    Decrypt(data []byte, key []byte) ([]byte, error)
}

// 2. AES-256 实现
type AESEncryption struct{}

func (a *AESEncryption) Encrypt(data []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    return gcm.Seal(nonce, nonce, data, nil), nil
}

// 3. 集成到上传流程
func (p *P2PService) UploadEncryptedFile(
    ctx context.Context,
    filePath string,
    encryptionKey []byte,
) (*file.MetaData, error) {
    // 1. 读取文件
    data, err := os.ReadFile(filePath)
    if err != nil {
        return nil, err
    }

    // 2. 加密
    encrypted, err := aes.Encrypt(data, encryptionKey)
    if err != nil {
        return nil, err
    }

    // 3. 上传加密数据
    return p.UploadEncryptedData(ctx, encrypted)
}
```

### 架构扩展

#### 1. 横向扩展（多节点集群）

**方案**: 使用负载均衡器

```
                   ┌─────────────┐
                   │ Load Balancer│
                   └──────┬──────┘
                          │
         ┌─────────────────┼─────────────────┐
         │                 │                 │
    ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
    │ Node 1  │      │ Node 2  │      │ Node 3  │
    └─────────┘      └─────────┘      └─────────┘
         │                 │                 │
    ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
    │Storage 1│      │Storage 2│      │Storage 3│
    └─────────┘      └─────────┘      └─────────┘
```

**实现**:
```go
// 负载均衡器
type LoadBalancer struct {
    nodes []*P2PService
    index int
    mu    sync.Mutex
}

func (lb *LoadBalancer) NextNode() *P2PService {
    lb.mu.Lock()
    defer lb.mu.Unlock()

    node := lb.nodes[lb.index]
    lb.index = (lb.index + 1) % len(lb.nodes)
    return node
}

func (lb *LoadBalancer) UploadFile(ctx context.Context, filePath string) (*file.MetaData, error) {
    node := lb.NextNode()
    return node.UploadFile(ctx, filePath)
}
```

#### 2. 高可用改进

**方案**: 主从复制 + 自动故障转移

```go
// 节点健康检查
type HealthChecker struct {
    nodes map[peer.ID]*P2PService
    health map[peer.ID]bool
    mu     sync.RWMutex
}

func (hc *HealthChecker) CheckAll() {
    for peerID, node := range hc.nodes {
        healthy := hc.checkNode(node)

        hc.mu.Lock()
        hc.health[peerID] = healthy
        hc.mu.Unlock()

        if !healthy {
            logrus.Warnf("Node %s is unhealthy", peerID)
            // 触发故障转移
        }
    }
}

func (hc *HealthChecker) checkNode(node *P2PService) bool {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // 尝试ping节点
    _, err := node.Host.Network().Ping(node.Host.ID())
    return err == nil
}
```

#### 3. 分布式存储

**方案**: 使用 IPFS 或类似系统

```go
// IPFS 适配器
type IPFSAdapter struct {
    shell *ipfsapi.Shell
}

func (ia *IPFSAdapter) AddFile(filePath string) (string, error) {
    file, _ := os.Open(filePath)
    defer file.Close()

    cid, err := ia.shell.Add(file)
    if err != nil {
        return "", err
    }

    return cid, nil
}

func (ia *IPFSAdapter) GetFile(cid string, destPath string) error {
    err := ia.shell.Get(cid, destPath)
    return err
}

// 集成到 P2P 服务
type P2PService struct {
    // ... 现有字段
    IPFS *IPFSAdapter
}
```

### 集成第三方服务

#### 1. 集成 Web3

**需求**: 在区块链上记录文件元数据

```go
import (
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
)

type BlockchainLogger struct {
    client *ethclient.Client
    contract *common.Address
}

func (bl *BlockchainLogger) LogFileUpload(cid string, timestamp int64) error {
    // 调用智能合约记录上传
    // ...
}
```

#### 2. 集成云存储

**需求**: 使用 S3 作为 Chunk 存储后端

```go
import "github.com/aws/aws-sdk-go/service/s3"

type S3Adapter struct {
    client *s3.S3
    bucket string
}

func (sa *S3Adapter) ReadChunk(key string) ([]byte, error) {
    result, err := sa.client.GetObject(&s3.GetObjectInput{
        Bucket: aws.String(sa.bucket),
        Key:    aws.String(key),
    })
    if err != nil {
        return nil, err
    }
    defer result.Body.Close()

    return io.ReadAll(result.Body)
}

func (sa *S3Adapter) WriteChunk(key string, data []byte) error {
    _, err := sa.client.PutObject(&s3.PutObjectInput{
        Bucket: aws.String(sa.bucket),
        Key:    aws.String(key),
        Body:   bytes.NewReader(data),
    })
    return err
}
```

#### 3. 集成消息队列

**需求**: 使用 Kafka 处理文件上传请求

```go
import "github.com/segmentio/kafka-go"

type KafkaProducer struct {
    writer *kafka.Writer
}

func (kp *KafkaProducer) PublishUploadRequest(request UploadRequest) error {
    data, _ := json.Marshal(request)

    return kp.writer.WriteMessages(
        context.Background(),
        kafka.Message{
            Topic: "file-uploads",
            Value: data,
        },
    )
}

type KafkaConsumer struct {
    reader *kafka.Reader
}

func (kc *KafkaConsumer) ConsumeUploadRequests() {
    for {
        msg, err := kc.reader.ReadMessage(context.Background())
        if err != nil {
            break
        }

        var request UploadRequest
        json.Unmarshal(msg.Value, &request)

        // 处理上传请求
        processUpload(request)
    }
}
```

## 社区资源

### 相关项目

- [IPFS](https://ipfs.io/) - 去中心化存储系统
- [Filecoin](https://filecoin.io/) - 去中心化存储网络
- [BitTorrent](https://www.bittorrent.com/) - P2P 文件共享
- [WebTorrent](https://webtorrent.io/) - 浏览器中的 P2P

### 讨论区/Issue

- GitHub Issues: [https://github.com/yourusername/p2pFileTransfer/issues](https://github.com/yourusername/p2pFileTransfer/issues)
- Discussions: [https://github.com/yourusername/p2pFileTransfer/discussions](https://github.com/yourusername/p2pFileTransfer/discussions)

### 贡献指南

1. Fork 项目
2. 创建特性分支
3. 提交 Pull Request
4. 等待 Code Review

### 学习资源

- [libp2p 文档](https://docs.libp2p.io/)
- [Go by Example](https://gobyexample.com/)
- [Effective Go](https://golang.org/doc/effective_go)
- [Go Programming Language](https://golang.org/doc/)

---

**完成！** 你已经拥有了完整的 P2P File Transfer System 开发文档集。

**文档索引**:
- [00-项目总览.md](00-项目总览.md)
- [01-核心架构解析.md](01-核心架构解析.md)
- [02-技术栈分析.md](02-技术栈分析.md)
- [03-配置与部署指南.md](03-配置与部署指南.md)
- [组件文档/](组件文档/)
  - [P2P核心服务组件](组件文档/P2P核心服务组件.md)
  - [Chameleon Merkle Tree组件](组件文档/Chameleon-Merkle-Tree组件.md)
  - [配置管理组件](组件文档/配置管理组件.md)
- [04-二次开发指南.md](04-二次开发指南.md)
- [05-常见问题与扩展思路.md](05-常见问题与扩展思路.md)
