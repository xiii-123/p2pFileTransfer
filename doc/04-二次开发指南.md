# 二次开发指南

## 开发准备

### 1. 环境搭建

#### 安装 Go

```bash
# 下载 Go 1.23+
# https://go.dev/dl/

# 验证安装
go version
# 输出: go version go1.23.8 ...
```

#### 克隆项目

```bash
git clone https://github.com/yourusername/p2pFileTransfer.git
cd p2pFileTransfer

# 下载依赖
go mod download

# 验证依赖
go mod verify
```

#### 安装开发工具

```bash
# 安装 golangci-lint（代码检查）
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 安装 gopls（语言服务器）
go install golang.org/x/tools/gopls@latest

# 安装 delve（调试器）
go install github.com/go-delve/delve/cmd/dlv@latest
```

### 2. 代码获取与构建

```bash
# 构建所有组件
go build -o bin/p2p ./cmd/p2p
go build -o bin/p2p-server ./cmd/server

# 运行测试
go test ./... -v

# 运行特定测试
go test ./pkg/p2p -v -run TestNewP2PService
```

### 3. 开发环境配置

#### VS Code 配置

**.vscode/settings.json**:
```json
{
    "go.useLanguageServer": true,
    "go.lintTool": "golangci-lint",
    "go.lintOnSave": "package",
    "go.formatTool": "goimports",
    "go.testFlags": ["-v"],
    "go.buildOnSave": "package",
    "go.coverOnSave": false,
    "go.coverageDecorator": {
        "type": "gutter"
    }
}
```

**.vscode/launch.json**:
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug P2P Server",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/server",
            "args": ["-config", "config/config.yaml"],
            "env": {
                "P2P_LOG_LEVEL": "debug"
            }
        },
        {
            "name": "Debug File Upload",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/p2p",
            "args": ["file", "upload", "test.txt", "-t", "regular"],
            "env": {
                "P2P_LOG_LEVEL": "debug"
            }
        }
    ]
}
```

#### GoLand 配置

1. 打开项目
2. File → Settings → Go
3. 设置 GOPATH 和 GOROOT
4. 启用 Go Modules 集成
5. 配置运行配置（Run Configuration）

### 4. 测试验证

```bash
# 运行所有测试
go test ./... -v

# 运行测试并生成覆盖率报告
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out

# 运行多节点测试（需要更多时间）
go test ./test -v -run TestMultiNode -timeout 10m
```

## 修改策略

### 推荐修改位置

#### 1. 配置扩展

**位置**: `pkg/config/loader.go`

**添加新配置项**:
```go
// 1. 定义配置结构
type NewFeatureConfig struct {
    Enabled bool   `mapstructure:"enabled"`
    Option  string `mapstructure:"option"`
}

// 2. 添加到 Config
type Config struct {
    // ... 现有字段
    NewFeature NewFeatureConfig `mapstructure:"new_feature"`
}

// 3. 添加验证
func (c *Config) Validate() error {
    // ... 现有验证

    if c.NewFeature.Enabled && c.NewFeature.Option == "" {
        return fmt.Errorf("new_feature.option required when enabled")
    }

    return nil
}

// 4. 添加环境变量绑定
func loadFromEnv(v *viper.Viper) {
    // ... 现有绑定

    if v.IsSet("NEW_FEATURE_ENABLED") {
        v.Set("new_feature.enabled", v.GetBool("NEW_FEATURE_ENABLED"))
    }
}
```

**优势**:
- ✅ 不影响现有代码
- ✅ 易于维护
- ✅ 向后兼容

#### 2. 插件开发

**位置**: 新建 `pkg/plugins/`

**插件接口定义**:
```go
// pkg/plugins/plugin.go
package plugins

type Plugin interface {
    Name() string
    Init(ctx context.Context, config interface{}) error
    Start(ctx context.Context) error
    Stop() error
}

type PluginManager struct {
    plugins map[string]Plugin
}

func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make(map[string]Plugin),
    }
}

func (pm *PluginManager) Register(p Plugin) {
    pm.plugins[p.Name()] = p
}

func (pm *PluginManager) InitAll(ctx context.Context) error {
    for _, p := range pm.plugins {
        if err := p.Init(ctx, nil); err != nil {
            return err
        }
    }
    return nil
}

func (pm *PluginManager) StartAll(ctx context.Context) error {
    for _, p := range pm.plugins {
        if err := p.Start(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (pm *PluginManager) StopAll() {
    for _, p := range pm.plugins {
        p.Stop()
    }
}
```

**实现插件**:
```go
// pkg/plugins/metrics.go
package plugins

import "context"

type MetricsPlugin struct {
    config MetricsConfig
}

type MetricsConfig struct {
    Port int
}

func (m *MetricsPlugin) Name() string {
    return "metrics"
}

func (m *MetricsPlugin) Init(ctx context.Context, config interface{}) error {
    // 初始化插件
    return nil
}

func (m *MetricsPlugin) Start(ctx context.Context) error {
    // 启动插件
    return nil
}

func (m *MetricsPlugin) Stop() error {
    // 停止插件
    return nil
}
```

**集成到服务**:
```go
// pkg/p2p/p2p.go
import "p2pFileTransfer/pkg/plugins"

type P2PService struct {
    // ... 现有字段
    PluginManager *plugins.PluginManager
}

func NewP2PService(ctx context.Context, config P2PConfig) (*P2PService, error) {
    // ... 现有代码

    // 创建插件管理器
    pm := plugins.NewPluginManager()
    pm.Register(&plugins.MetricsPlugin{})

    // 初始化和启动插件
    pm.InitAll(ctx)
    pm.StartAll(ctx)

    return &P2PService{
        // ... 现有字段
        PluginManager: pm,
    }, nil
}

func (p *P2PService) Shutdown() error {
    // 停止插件
    p.PluginManager.StopAll()

    // ... 现有清理代码
    return nil
}
```

#### 3. 子类覆盖

**位置**: `pkg/p2p/peerSelector.go`

**自定义节点选择器**:
```go
// 创建自定义选择器
type LatencyBasedPeerSelector struct {
    latencyMap map[peer.ID]time.Duration
    mutex      sync.RWMutex
}

func (s *LatencyBasedPeerSelector) SelectPeer(providers []peer.ID) peer.ID {
    s.mutex.RLock()
    defer s.mutex.RUnlock()

    // 选择延迟最低的节点
    var selected peer.ID
    minLatency := time.Duration(math.MaxInt64)

    for _, provider := range providers {
        if latency, exists := s.latencyMap[provider]; exists {
            if latency < minLatency {
                minLatency = latency
                selected = provider
            }
        }
    }

    if selected == "" {
        // 如果没有延迟数据，随机选择
        return providers[rand.Intn(len(providers))]
    }

    return selected
}

func (s *LatencyBasedPeerSelector) UpdateLatency(peerID peer.ID, latency time.Duration) {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    s.latencyMap[peerID] = latency
}

// 使用自定义选择器
service.PeerSelector = &LatencyBasedPeerSelector{
    latencyMap: make(map[peer.ID]time.Duration),
}
```

### 应避免的修改

#### 1. 核心不可修改部分

**❌ 不要修改**:

- **libp2p 核心协议**: 如需修改，考虑 fork libp2p
- **Merkle 树根哈希计算**: 破坏兼容性
- **DHT 协议**: 影响网络互操作性
- **元数据格式**: 导致旧版本无法读取

**⚠️ 谨慎修改**:

- **网络协议**: 需要更新所有节点
- **存储格式**: 需要迁移工具
- **配置结构**: 保持向后兼容

#### 2. 兼容性风险点

**协议版本**:
```go
const (
    AnnounceProtocol = "p2pFileTransfer/Announce/1.0.0"  // ❌ 不要修改
    LookupProtocol   = "p2pFileTransfer/Lookup/1.0.0"    // ❌ 不要修改
)

// ✅ 正确做法：添加新协议
const AnnounceProtocolV2 = "p2pFileTransfer/Announce/2.0.0"
```

**元数据结构**:
```go
type MetaData struct {
    RootHash    []byte        // ❌ 不要删除或重命名字段
    TreeType    string        // ❌ 不要修改现有字段
    Description string        // ✅ 可以添加新字段
    NewField    string        `json:"new_field,omitempty"` // ✅ 添加可选字段
}
```

## 定制化示例

### 示例1: 添加文件下载进度回调

**需求**: 在文件下载时显示实时进度

**实现步骤**:

#### 1. 定义回调类型

```go
// pkg/p2p/getFile.go
type ProgressCallback func(current, total int)

// 或使用更详细的进度信息
type ProgressInfo struct {
    Current    int
    Total      int
    BytesTransferred int64
    Speed     float64  // MB/s
}

type DetailedProgressCallback func(ProgressInfo)
```

#### 2. 修改下载函数

```go
func (p *P2PService) DownloadFileWithProgress(
    ctx context.Context,
    metadata *file.MetaData,
    destPath string,
    callback ProgressCallback,
) error {
    // ... 现有代码

    // 在下载每个 chunk 后调用回调
    for i, result := range results {
        // ... 下载 chunk

        // 调用进度回调
        if callback != nil {
            callback(i+1, len(metadata.Leaves))
        }
    }

    return nil
}
```

#### 3. 使用回调

```go
// cmd/p2p/file/download.go
var downloadCmd = &cobra.Command{
    Use:   "download <cid> <dest>",
    Short: "Download a file",
    Args:  cobra.ExactArgs(2),
    Run: func(cmd *cobra.Command, args []string) {
        cid := args[0]
        dest := args[1]

        // 加载元数据
        metadata := loadMetadata(cid)

        // 创建进度条
        progress := make(chan int, len(metadata.Leaves))
        go func() {
            for current := range progress {
                percent := float64(current) / float64(len(metadata.Leaves)) * 100
                fmt.Printf("\rProgress: %.1f%% (%d/%d)", percent, current, len(metadata.Leaves))
            }
            fmt.Println()  // 换行
        }()

        // 下传文件（带进度）
        err := service.DownloadFileWithProgress(ctx, metadata, dest, func(current, total int) {
            progress <- current
        })

        close(progress)

        if err != nil {
            log.Fatal(err)
        }
    },
}
```

### 示例2: 修改节点选择策略

**需求**: 优先选择延迟低的节点

**实现步骤**:

#### 1. 实现延迟测量

```go
// pkg/p2p/latencyTracker.go
package p2p

import (
    "context"
    "time"
    "github.com/libp2p/go-libp2p/core/peer"
)

type LatencyTracker struct {
    latencies map[peer.ID][]time.Duration
    mutex     sync.RWMutex
}

func NewLatencyTracker() *LatencyTracker {
    return &LatencyTracker{
        latencies: make(map[peer.ID][]time.Duration),
    }
}

func (lt *LatencyTracker) Measure(ctx context.Context, peerID peer.ID) (time.Duration, error) {
    start := time.Now()

    // 发送 ping 请求
    // ... 实现延迟测量

    latency := time.Since(start)

    // 记录延迟
    lt.mutex.Lock()
    defer lt.mutex.Unlock()

    if lt.latencies[peerID] == nil {
        lt.latencies[peerID] = []time.Duration{}
    }

    lt.latencies[peerID] = append(lt.latencies[peerID], latency)

    // 只保留最近 10 次测量
    if len(lt.latencies[peerID]) > 10 {
        lt.latencies[peerID] = lt.latencies[peerID][1:]
    }

    return latency, nil
}

func (lt *LatencyTracker) GetAverageLatency(peerID peer.ID) time.Duration {
    lt.mutex.RLock()
    defer lt.mutex.RUnlock()

    latencies := lt.latencies[peerID]
    if len(latencies) == 0 {
        return 0
    }

    var sum time.Duration
    for _, l := range latencies {
        sum += l
    }

    return sum / time.Duration(len(latencies))
}
```

#### 2. 实现基于延迟的选择器

```go
// pkg/p2p/peerSelector.go
type LatencyBasedSelector struct {
    tracker *LatencyTracker
}

func (s *LatencyBasedSelector) SelectPeer(providers []peer.ID) peer.ID {
    var selected peer.ID
    minLatency := time.Duration(math.MaxInt64)

    for _, provider := range providers {
        latency := s.tracker.GetAverageLatency(provider)
        if latency > 0 && latency < minLatency {
            minLatency = latency
            selected = provider
        }
    }

    // 如果没有延迟数据，随机选择
    if selected == "" {
        return providers[rand.Intn(len(providers))]
    }

    return selected
}
```

#### 3. 集成到服务

```go
// pkg/p2p/p2p.go
type P2PService struct {
    // ... 现有字段
    LatencyTracker *LatencyTracker
}

func NewP2PService(ctx context.Context, config P2PConfig) (*P2PService, error) {
    // ... 现有代码

    lt := NewLatencyTracker()

    return &P2PService{
        // ... 现有字段
        LatencyTracker: lt,
        PeerSelector:   &LatencyBasedSelector{tracker: lt},
    }, nil
}
```

### 示例3: 添加新的 HTTP API 端点

**需求**: 添加批量文件上传的 API 端点

**实现步骤**:

#### 1. 定义处理器

```go
// cmd/api/handlers.go

// handleBatchUpload 处理批量文件上传
func (s *Server) handleBatchUpload(w http.ResponseWriter, r *http.Request) {
    // 解析 multipart 表单
    err := r.ParseMultipartForm(32 << 20) // 32MB
    if err != nil {
        s.respondError(w, http.StatusBadRequest, fmt.Sprintf("Failed to parse form: %v", err))
        return
    }

    files := r.MultipartForm.File["files"]
    if len(files) == 0 {
        s.respondError(w, http.StatusBadRequest, "No files provided")
        return
    }

    treeType := r.FormValue("tree_type")
    if treeType == "" {
        treeType = "regular"
    }

    // 上传所有文件
    ctx := r.Context()
    results := make([]map[string]interface{}, 0, len(files))

    for _, fileHeader := range files {
        file, err := fileHeader.Open()
        if err != nil {
            s.respondError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to open file: %v", err))
            return
        }

        // 上传单个文件
        var result map[string]interface{}
        if treeType == "chameleon" {
            result, err = s.uploadFileChameleon(ctx, file, fileHeader.Filename, "")
        } else {
            result, err = s.uploadFileRegular(ctx, file, fileHeader.Filename, "")
        }
        file.Close()

        if err != nil {
            s.respondError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to upload %s: %v", fileHeader.Filename, err))
            return
        }

        results = append(results, result)
    }

    s.respondJSON(w, http.StatusOK, map[string]interface{}{
        "success": true,
        "data": map[string]interface{}{
            "uploaded": len(results),
            "files":    results,
        },
    })
}
```

#### 2. 注册路由

```go
// cmd/api/server.go

func (s *Server) setupRoutes() {
    mux := http.NewServeMux()

    // 现有路由
    mux.HandleFunc("/api/health", s.handleHealth)
    mux.HandleFunc("/api/v1/files/upload", s.handleFileUpload)

    // 新增批量上传路由
    mux.HandleFunc("/api/v1/files/batch-upload", s.withCORS(s.handleBatchUpload))

    s.router = mux
}
```

#### 3. 测试新端点

```bash
# 测试批量上传
curl -X POST http://localhost:8080/api/v1/files/batch-upload \
  -F "files=@test1.txt" \
  -F "files=@test2.txt" \
  -F "tree_type=regular"
```

#### 4. 添加单元测试

```go
// cmd/api/api_test.go

func TestBatchFileUpload(t *testing.T) {
    t.Log("Testing batch file upload")

    // 创建测试文件
    file1, _ := os.CreateTemp("", "test1_*.txt")
    file2, _ := os.CreateTemp("", "test2_*.txt")
    defer os.Remove(file1.Name())
    defer os.Remove(file2.Name())

    file1.WriteString("Test file 1")
    file2.WriteString("Test file 2")

    // 准备请求
    body := &bytes.Buffer{}
    writer := multipart.NewWriter(body)

    part1, _ := writer.CreateFormFile("files", "test1.txt")
    part1.Write([]byte("Test file 1"))

    part2, _ := writer.CreateFormFile("files", "test2.txt")
    part2.Write([]byte("Test file 2"))

    writer.WriteField("tree_type", "regular")
    writer.Close()

    req, _ := http.NewRequest("POST", testServerAddr+"/api/v1/files/batch-upload", body)
    req.Header.Set("Content-Type", writer.FormDataContentType())

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        t.Fatalf("Failed to upload files: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Errorf("Expected status 200, got %d", resp.StatusCode)
    }

    result, _ := parseJSONResponse(resp)
    if !result["success"].(bool) {
        t.Error("Expected success to be true")
    }

    t.Log("✓ Batch upload test passed")
}
```

### 示例4: 添加加密传输

**需求**: 在传输时加密 Chunk 数据

**实现步骤**:

#### 1. 定义加密接口

```go
// pkg/p2p/encryption.go
package p2p

type Encryption interface {
    Encrypt(data []byte) ([]byte, error)
    Decrypt(data []byte) ([]byte, error)
}

type AESEncryption struct {
    key []byte
}

func NewAESEncryption(key []byte) *AESEncryption {
    return &AESEncryption{key: key}
}

func (e *AESEncryption) Encrypt(data []byte) ([]byte, error) {
    // 实现 AES 加密
    // ...
}

func (e *AESEncryption) Decrypt(data []byte) ([]byte, error) {
    // 实现 AES 解密
    // ...
}
```

#### 2. 修改 Chunk 传输

```go
// pkg/p2p/chunk.go
func (p *P2PService) GetChunkDataEncrypted(
    ctx context.Context,
    peerID peer.ID,
    chunkHash []byte,
    encryption Encryption,
) ([]byte, error) {
    // 1. 获取加密数据
    encryptedData, err := p.GetChunkData(ctx, peerID, chunkHash)
    if err != nil {
        return nil, err
    }

    // 2. 解密
    data, err := encryption.Decrypt(encryptedData)
    if err != nil {
        return nil, err
    }

    return data, nil
}

func (p *P2PService) ProvideChunkEncrypted(
    ctx context.Context,
    chunkHash []byte,
    encryption Encryption,
) error {
    // 1. 读取原始数据
    data, err := p.ReadChunk(chunkHash)
    if err != nil {
        return err
    }

    // 2. 加密
    encryptedData, err := encryption.Encrypt(data)
    if err != nil {
        return err
    }

    // 3. 提供加密数据
    // ... 实现
}
```

#### 3. 配置加密

```go
// pkg/config/loader.go
type EncryptionConfig struct {
    Enabled    bool   `mapstructure:"enabled"`
    Algorithm  string `mapstructure:"algorithm"`
    Key        string `mapstructure:"key"`
}

type Config struct {
    // ... 现有字段
    Encryption EncryptionConfig `mapstructure:"encryption"`
}
```

## 调试技巧

### 1. 日志查看

```go
// 使用 logrus 记录详细日志
import "github.com/sirupsen/logrus"

logrus.SetLevel(logrus.DebugLevel)

logrus.WithFields(logrus.Fields{
    "peer": peerID,
    "chunk": fmt.Sprintf("%x", chunkHash),
    "retry": retry,
}).Debug("Downloading chunk")
```

### 2. 调试工具

#### Delve（命令行调试器）

```bash
# 安装
go install github.com/go-delve/delve/cmd/dlv@latest

# 调试程序
dlv debug ./cmd/server -- -config config/config.yaml

# 常用命令
(dlv) break main.main          # 设置断点
(dlv) break p2p.NewP2PService  # 在函数处设置断点
(dlv) continue                 # 继续执行
(dlv) next                     # 下一步
(dlv) step                     # 步入
(dlv) print variableName       # 打印变量
(dlv) locals                   # 打印局部变量
(dlv) args                     # 打印函数参数
(dlv) goroutines               # 列出所有 goroutines
(dlv) goroutine 5              # 切换到 goroutine 5
```

#### VS Code 调试

1. 设置断点：点击行号左侧
2. 按 F5 或点击"Run and Debug"
3. 查看变量：鼠标悬停或查看变量面板
4. 查看调用栈：调用栈面板

### 3. 性能分析

#### CPU 性能分析

```bash
# 生成 CPU profile
go test -cpuprofile=cpu.prof ./pkg/p2p

# 分析 profile
go tool pprof cpu.prof

# 常用命令
(pprof) top        # 显示 top 函数
(pprof) list funcName  # 显示函数代码
(pprof) web        # 生成可视化图（需要 graphviz）
```

#### 内存分析

```bash
# 生成 memory profile
go test -memprofile=mem.prof ./pkg/p2p

# 分析
go tool pprof mem.prof

(pprof) top
(pprof) list funcName
```

#### 追踪分析

```bash
# 启用追踪
go test -trace=trace.out ./pkg/p2p

# 分析追踪
go tool trace trace.out
```

### 4. 网络调试

#### 抓包分析

```bash
# 使用 tcpdump
tcpdump -i any -w capture.pcap port 8000

# 使用 Wireshark 打开 capture.pcap
```

#### 日志网络流量

```go
// 添加网络流量日志
func (p *P2PService) logNetworkTraffic(peerID peer.ID, sent, recv int) {
    logrus.WithFields(logrus.Fields{
        "peer":    peerID,
        "sent":    sent,
        "recv":    recv,
        "traffic": "network",
    }).Debug("Network traffic")
}
```

### 5. 常见问题定位

#### 问题1: 连接失败

```bash
# 检查防火墙
sudo ufw status

# 检查端口监听
netstat -tlnp | grep p2p

# 测试连接
telnet 127.0.0.1 8000
```

#### 问题2: DHT 不工作

```go
// 启用 DHT 调试日志
import dht "github.com/libp2p/go-libp2p-kad-dht"

kdht, err := dht.New(ctx, host,
    dht.Mode(dht.ModeServer),
    dht.Vis(true),  // 启用可视化
)
```

#### 问题3: 内存泄漏

```bash
# 运行时内存 profile
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 分析
go tool pprof heap.prof
```

## 代码质量

### 1. 代码检查

```bash
# 使用 golangci-lint
golangci-lint run

# 使用 go vet
go vet ./...

# 使用 staticcheck
go install honnef.co/go/tools/cmd/staticcheck@latest
staticcheck ./...
```

### 2. 代码格式化

```bash
# 格式化代码
goimports -w .

# 或使用 gofmt
gofmt -s -w .
```

### 3. 测试覆盖率

```bash
# 生成覆盖率报告
go test ./... -coverprofile=coverage.out

# 查看覆盖率
go tool cover -func=coverage.out

# 生成 HTML 报告
go tool cover -html=coverage.out -o coverage.html
```

## 贡献指南

### 1. 代码风格

- 遵循 [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- 使用 `gofmt` 格式化代码
- 添加必要的注释和文档
- 编写测试用例

### 2. 提交 PR

1. Fork 项目
2. 创建特性分支
3. 提交代码
4. 推送到分支
5. 创建 Pull Request

### 3. Pull Request 模板

```markdown
## 描述
简要描述你的修改

## 类型
- [ ] Bug 修复
- [ ] 新功能
- [ ] 重构
- [ ] 文档更新
- [ ] 性能优化

## 测试
- [ ] 添加了测试用例
- [ ] 所有测试通过

## 检查清单
- [ ] 代码通过 golangci-lint
- [ ] 代码通过 go vet
- [ ] 添加了必要的文档
- [ ] 更新了 README（如需要）
```

---

**下一步**: 阅读 [05-常见问题与扩展思路.md](05-常见问题与扩展思路.md)
