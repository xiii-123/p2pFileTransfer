# P2P File Transfer System - 完整项目文档

## 目录

1. [项目概述](#1-项目概述)
2. [核心架构](#2-核心架构)
3. [技术栈分析](#3-技术栈分析)
4. [配置与部署](#4-配置与部署)
5. [二次开发指南](#5-二次开发指南)
6. [常见问题与扩展](#6-常见问题与扩展)

---

## 1. 项目概述

### 1.1 基本信息

- **仓库地址**: D:\Work-Files\p2pFileTransfer
- **主要语言**: Go 1.23+
- **代码规模**: 约 6,376 行 Go 代码
- **文档数量**: 17 个 Markdown 文档
- **最新版本**: v1.0.0

### 1.2 项目简介

**P2P File Transfer System** 是一个基于 libp2p 的去中心化点对点文件传输系统，专注于高效、安全、可靠的文件分发。

#### 核心特性

1. **双 Merkle 树支持**
   - **Regular Merkle Tree**: 标准 SHA256 哈希，不可变，适合一次性上传
   - **Chameleon Merkle Tree**: 基于椭圆曲线 P256 的可变色哈希，支持文件内容修改（需私钥）

2. **高效传输机制**
   - 文件分块传输（默认 256KB/块）
   - 并发下载（默认 16 个并发）
   - 流式处理，内存占用仅 32KB
   - SHA256 哈希验证确保数据完整性

3. **完整的 P2P 网络功能**
   - 基于 Kademlia 的 DHT 路由
   - 自动节点发现
   - Chunk 可用性公告
   - Provider 查询机制

4. **用户友好的 CLI 工具**
   - 基于 Cobra 框架
   - 支持文件上传、下载、查询
   - DHT 操作命令
   - 节点管理功能
   - 实时进度显示

5. **灵活的配置系统**
   - YAML 配置文件
   - 环境变量覆盖
   - 多级配置验证

#### 解决的问题

- ✅ **中心化依赖**: 无需中央服务器，完全去中心化
- ✅ **大文件传输**: 高效的分块传输和并发下载
- ✅ **数据完整性**: Merkle 树验证确保文件未被篡改
- ✅ **可编辑性**: Chameleon 哈希支持已发布文件的修改
- ✅ **性能优化**: 低内存占用，支持大文件传输

### 1.3 核心价值

#### 主要优势

1. **性能优异**
   - 流式下载，内存占用极低
   - 并发传输，充分利用带宽
   - 智能重试，提高成功率

2. **安全可靠**
   - 双重哈希验证（SHA256 + Merkle 树）
   - 椭圆曲线加密（P256）
   - 完整性验证机制

3. **高度灵活**
   - 双 Merkle 树支持，适应不同场景
   - 丰富的配置选项
   - 可扩展的架构设计

4. **易于使用**
   - 完整的 CLI 工具
   - 清晰的命令结构
   - 详细的文档和示例

5. **生产就绪**
   - 完善的测试覆盖（40+ 测试用例）
   - 优雅关闭机制
   - 健壮的错误处理

#### 独特性

- ✨ **Chameleon Merkle Tree**: 业界少有的可变色哈希树实现，支持文件修改而无需重新上传全部内容
- ✨ **双模式支持**: 同时支持标准 Merkle 树和可变色 Merkle 树，灵活适应不同需求
- ✨ **高效内存管理**: 流式下载大文件，内存占用仅 32KB，远低于传统方案
- ✨ **完整的测试**: 包含单元测试、集成测试、多节点测试，确保代码质量

### 1.4 项目结构

```
p2pFileTransfer/
├── cmd/                          # 命令行入口
│   ├── p2p/                      # CLI 工具
│   │   ├── main.go               # 主入口
│   │   ├── root.go               # 根命令
│   │   ├── version.go            # 版本命令
│   │   ├── server.go             # 服务命令
│   │   └── file/                 # 文件操作子命令
│   │       ├── cmd.go            # 文件命令组
│   │       └── upload.go         # 上传实现
│   └── server/                   # 服务器独立入口
│       └── main.go
│
├── pkg/                          # 核心功能包
│   ├── p2p/                      # P2P 网络核心
│   │   ├── p2p.go                # 核心服务（164 行）
│   │   ├── dht.go                # DHT 实现（580 行）
│   │   ├── chunk.go              # 分块处理（302 行）
│   │   ├── getFile.go            # 文件下载（534 行）
│   │   ├── merkletree.go         # Merkle 树工具（83 行）
│   │   ├── antiLeecher.go        # 反吸血虫（47 行）
│   │   ├── connManager.go        # 连接管理（246 行）
│   │   ├── peerSelector.go       # 节点选择（161 行）
│   │   └── utils.go              # 工具函数（95 行）
│   │
│   ├── chameleonMerkleTree/      # 可变色默克尔树
│   │   ├── chameleonMerkleTree.go       # 接口定义
│   │   ├── chameleonMerkleTreeImpl.go   # 核心实现（370 行）
│   │   ├── chameleon.go                 # Chameleon 哈希（108 行）
│   │   ├── chameleonInfo.go             # 密钥结构
│   │   └── utils.go                     # 工具函数
│   │
│   ├── config/                   # 配置管理
│   │   └── loader.go              # 配置加载（384 行）
│   │
│   └── file/                     # 文件处理
│       ├── file.go                # 元数据定义
│       └── fsAdapter.go           # 文件系统适配器
│
├── config/                       # 配置文件
│   ├── config.example.yaml       # 配置模板
│   └── config.yaml               # 实际配置
│
├── test/                         # 测试套件
│   ├── integration_test.go       # 集成测试（941 行）
│   ├── multinode_test.go         # 多节点测试
│   ├── utils_test.go             # 工具测试
│   └── README.md                 # 测试文档
│
├── doc/                          # 项目文档（17个文档）
├── files/                        # Chunk 存储目录（运行时生成）
├── metadata/                     # 元数据存储目录（运行时生成）
│
├── go.mod                        # Go 模块定义
├── go.sum                        # 依赖校验和
├── LICENSE                       # MIT 许可证
├── README.md                     # 项目说明
├── CONFIGURATION_GUIDE.md        # 配置指南
├── build.bat                     # Windows 构建脚本
└── run_multinode_tests.*         # 多节点测试脚本
```

### 1.5 快速开始

#### 环境要求

- Go 1.23 或更高版本
- Git（用于克隆仓库）
- Windows/Linux/macOS 操作系统

#### 安装步骤

```bash
# 1. 克隆仓库
git clone https://github.com/xiii-123/p2pFileTransfer.git
cd p2pFileTransfer

# 2. 下载依赖
go mod download

# 3. 构建 CLI 工具和服务器
go build -o bin/p2p ./cmd/p2p
go build -o bin/p2p-server ./cmd/server

# 4. 验证安装
./bin/p2p version
```

#### 快速使用

**1. 上传文件（使用 Regular Merkle Tree）**
```bash
# 上传文件（推荐用于一次性上传）
./bin/p2p file upload myfile.txt -t regular -d "My important file"
```

**2. 上传文件（使用 Chameleon Merkle Tree）**
```bash
# 上传文件（可编辑，需要妥善保管私钥）
./bin/p2p file upload myfile.txt -t chameleon -d "Editable version"
```

**3. 启动 P2P 服务**
```bash
# 使用默认配置
./bin/p2p-server

# 使用自定义配置
./bin/p2p-server --config config/config.yaml
```

### 1.6 Merkle 树类型选择

| 特性 | Chameleon Merkle Tree | Regular Merkle Tree |
|------|----------------------|---------------------|
| 可编辑性 | ✓ 支持（需要私钥） | ✗ 不支持 |
| 算法复杂度 | 高（椭圆曲线 P256） | 低（标准 SHA256） |
| 性能 | 较慢 | 较快 |
| 密钥管理 | 需要生成和保存密钥对 | 不需要密钥 |
| 适用场景 | 需要修改的文件 | 一次性上传，不需要修改 |

**使用建议**：
- 需要版本控制 → 使用 **Chameleon**
- 追求性能 → 使用 **Regular**
- 一次性发布 → 使用 **Regular**
- 动态内容 → 使用 **Chameleon**

### 1.7 性能指标

#### 资源使用

| 指标 | 值 |
|------|-----|
| 内存占用 (1GB 文件) | 32 KB |
| Goroutine 数量 | 16 (恒定) |
| Chunk 下载延迟 | < 100 ms |
| 并发下载数 | 16 |

---

## 2. 核心架构

### 2.1 系统分层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        CLI / Application Layer                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
│  │   cmd/p2p    │  │ cmd/server   │  │  Future GUI  │           │
│  │  (CLI Tool)  │  │ (Standalone) │  │   (Optional) │           │
│  └──────────────┘  └──────────────┘  └──────────────┘           │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                      Business Logic Layer                       │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    pkg/p2p/ (Core)                        │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │  │
│  │  │   DHT   │ │ Chunk   │ │  File   │ │  Conn   │          │  │
│  │  │ Router  │ │ Transfer│ │ Manager │ │ Manager │          │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘          │  │
│  └───────────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                    Algorithm Layer                              │
│  ┌─────────────────────┐  ┌─────────────────────┐               │
│  │  Chameleon Merkle   │  │   Regular Merkle    │               │
│  │       Tree          │  │       Tree          │               │
│  │  (Elliptic P256)    │  │    (SHA256)         │               │
│  └─────────────────────┘  └─────────────────────┘               │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                      Infrastructure Layer                       │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐             │
│  │ libp2p  │  │   DHT   │  │  Config │  │  File   │             │
│  │ Network │  │ (Kadem) │  │ Manager │  │  System │             │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘             │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 架构风格

#### 分层架构 (Layered Architecture)

- **表示层**: `cmd/` - CLI 和服务器入口
- **业务逻辑层**: `pkg/p2p/`, `pkg/chameleonMerkleTree/` - 核心功能
- **基础设施层**: libp2p, 文件系统, 配置管理

#### 模块化架构 (Modular Architecture)

每个包 (`pkg/`) 都是独立模块：
- `pkg/p2p/` - P2P 网络模块
- `pkg/chameleonMerkleTree/` - Merkle 树模块
- `pkg/config/` - 配置模块
- `pkg/file/` - 文件处理模块

### 2.3 数据流分析

#### 文件上传数据流

```
[用户文件]
    │
    ▼
[文件读取] (os.Open)
    │
    ▼
[分块处理] (CalculateChunkHashes)
    │
    ├─> [Chunk 1] ─> SHA256 ─> Hash1
    ├─> [Chunk 2] ─> SHA256 ─> Hash2
    └─> [Chunk N] ─> SHA256 ─> HashN
    │
    ▼
[Merkle Tree 构建]
    │
    ├─> Chameleon: Hashes ─> ECDSA ─> RootHash
    └─> Regular: Hashes ─> SHA256 ─> RootHash
    │
    ▼
[生成 Metadata]
    │
    ▼
[存储 Chunks] + [DHT 公告] + [保存 Metadata]
```

#### 文件下载数据流

```
[Metadata]
    │
    ▼
[解析 ChunkList]
    │
    ▼
[For Each Chunk]:
    │
    ├─> [DHT.FindProviders]
    │       │
    │       ▼
    │   [Provider List]
    │       │
    │       ▼
    │   [PeerSelector.Select]
    │       │
    │       ▼
    │   [Download Chunk]
    │       │
    │       ▼
    │   [Verify SHA256]
    │       │
    │       ├─> Valid ─> [Save Chunk]
    │       └─> Invalid ─> [Blacklist Peer]
    │
    ▼
[重组文件] + [验证 RootHash]
```

### 2.4 关键技术决策

#### 1. 为什么选择 libp2p？

**原因**:
- ✅ 成熟的 P2P 网络库，IPFS 的核心
- ✅ 支持多种传输协议（TCP, WebSocket, QUIC）
- ✅ 内置 NAT 穿透
- ✅ 活跃的社区和持续的维护
- ✅ 跨平台支持

#### 2. 为什么实现双 Merkle 树？

**原因**:
- **Regular Merkle Tree**: 满足标准需求，性能优异
- **Chameleon Merkle Tree**: 支持文件修改，适用于版本控制场景
- 提供灵活性，让用户根据场景选择

#### 3. 为什么采用流式下载？

**原因**:
- **内存效率**: 1GB 文件仅需 32KB 内存
- **支持大文件**: 理论上无文件大小限制
- **实时验证**: 边下载边验证，及时发现错误

#### 4. 为什么使用工作池模式？

**原因**:
- **资源控制**: 限制并发 goroutine 数量
- **避免过载**: 防止创建过多连接
- **性能优化**: 减少 goroutine 创建和销毁开销

#### 5. 为什么需要连接管理器？

**原因**:
- **防止单点过载**: 限制对单个节点的并发连接数
- **黑名单机制**: 自动屏蔽失败的节点
- **统计信息**: 跟踪节点性能
- **负载均衡**: 优化节点选择

---

## 3. 技术栈分析

### 3.1 核心技术栈

| 类别 | 技术/工具 | 版本 | 用途 |
|------|-----------|------|------|
| **语言** | Go | 1.23+ | 主要开发语言 |
| **P2P 框架** | libp2p | v0.41.1 | 点对点网络实现 |
| **DHT 实现** | go-libp2p-kad-dht | v0.31.0 | Kademlia 分布式哈希表 |
| **多地址** | go-multiaddr | v0.15.0 | 自寻址格式 |
| **日志** | logrus | v1.9.3 | 结构化日志 |
| **配置** | viper | v1.21.0 | 配置管理 |
| **CLI 框架** | cobra | v1.10.2 | 命令行界面 |
| **测试** | testify | v1.11.1 | 测试框架 |
| **加密** | elliptic | 标准库 | 椭圆曲线密码学 |
| **哈希** | crypto/sha256 | 标准库 | SHA256 哈希 |

### 3.2 核心依赖详解

#### 1. libp2p (v0.41.1)

**主要功能**:
- 节点身份管理（Peer ID）
- 传输协议（TCP, WebSocket, QUIC）
- NAT 穿透
- 流 multiplexing
- 加密通信（Noise Protocol）

#### 2. go-libp2p-kad-dht (v0.31.0)

**主要功能**:
- PutValue/GetValue: 键值对存储
- FindProviders: 查找内容提供者
- Provide: 公告内容可用性
- Bootstrap: 网络引导

#### 3. cobra (v1.10.2)

**主要功能**:
- 子命令嵌套
- 参数验证
- 自动生成帮助
- 自动补全
- 别名支持

#### 4. viper (v1.21.0)

**主要功能**:
- 多格式支持（JSON, YAML, TOML）
- 环境变量读取
- 命令行参数绑定
- 默认值设置

### 3.3 依赖关系图

```
p2pFileTransfer
├── libp2p (v0.41.1)
│   ├── go-libp2p-core
│   ├── go-libp2p-transport
│   ├── go-libp2p-noise
│   └── go-multiaddr (v0.15.0)
│
├── go-libp2p-kad-dht (v0.31.0)
│   ├── go-libp2p-core
│   ├── go-libp2p-record
│   └── go-libp2p-kbucket
│
└── cobra (v1.10.2)
    ├── spf13/pflag
    └── spf13/cast
```
---

## 4. 配置与部署

### 4.1 环境配置

#### 开发环境

```bash
# 1. 安装 Go 1.23+
# 下载: https://golang.org/dl/

# 2. 设置环境变量
export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/go
export GO111MODULE=on

# 3. 克隆项目
git clone https://github.com/yourusername/p2pFileTransfer.git
cd p2pFileTransfer

# 4. 下载依赖
go mod download

# 5. 运行开发服务器
go run cmd/server/main.go
```

#### 生产环境

**系统要求**:
- Linux (推荐 Ubuntu 20.04+ 或 CentOS 8+)
- macOS 10.15+
- Windows Server 2019+

**编译生产版本**:

```bash
# Linux
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-linux-amd64 ./cmd/p2p

# macOS
GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-darwin-amd64 ./cmd/p2p

# Windows
GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o bin/p2p-windows-amd64.exe ./cmd/p2p
```

### 4.2 配置文件

#### 主配置文件

**位置**: `config/config.yaml`

```yaml
# ========== 网络配置 ==========
network:
  port: 0               # 监听端口 (0 = 随机分配)
  insecure: false       # 生产环境必须为 false
  bootstrap_peers:      # Bootstrap 节点地址
    - /ip4/127.0.0.1/tcp/8001/p2p/QmPeerID1
  protocol_prefix: "/p2p-file-transfer"
  auto_refresh: true
  namespace: "p2p-file-transfer"

# ========== 存储配置 ==========
storage:
  chunk_path: "files"           # Chunk 存储路径
  block_size: 262144            # 256KB
  buffer_number: 16

# ========== 性能配置 ==========
performance:
  max_retries: 3                # 最大重试次数
  max_concurrency: 16           # 最大并发下载数
  request_timeout: 5            # 请求超时（秒）
  data_timeout: 30              # 数据传输超时（秒）
  dht_timeout: 10               # DHT 操作超时（秒）

# ========== 日志配置 ==========
logging:
  level: "info"                 # 日志级别 (debug, info, warn, error)
  format: "text"                # 日志格式 (json, text)

# ========== 反吸血虫配置 ==========
anti_leecher:
  enabled: true                 # 启用反吸血虫机制
  min_success_rate: 0.5         # 最小成功率阈值
  min_requests: 10              # 黑名单前的最小请求数
```

### 4.3 部署方案

#### 方案 A: 直接部署（Systemd）

**Systemd 服务文件** (`/etc/systemd/system/p2p.service`):

```ini
[Unit]
Description=P2P File Transfer Service
After=network.target

[Service]
Type=simple
User=p2p
Group=p2p
ExecStart=/usr/local/bin/p2p-server -config /etc/p2p/config.yaml
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

**启动服务**:
```bash
sudo systemctl daemon-reload
sudo systemctl enable p2p
sudo systemctl start p2p
sudo systemctl status p2p
```

#### 方案 B: Docker 部署

**Dockerfile**:
```dockerfile
FROM golang:1.23-alpine AS builder

WORKDIR /app
COPY . .
RUN go mod download
RUN go build -ldflags="-s -w" -o p2p-server ./cmd/server

FROM alpine:latest

RUN apk add --no-cache ca-certificates tzdata

WORKDIR /app

COPY --from=builder /app/p2p-server /app/p2p-server
COPY config/config.prod.yaml /app/config.yaml

RUN mkdir -p /app/files /app/metadata

EXPOSE 4001

ENTRYPOINT ["/app/p2p-server"]
CMD ["-config", "/app/config.yaml"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  p2p:
    build: .
    container_name: p2p-server
    restart: unless-stopped
    ports:
      - "4001:4001"
      - "8000:8000"
    volumes:
      - ./data:/app/files
      - ./metadata:/app/metadata
      - ./config.prod.yaml:/app/config.yaml:ro
    environment:
      - P2P_LOG_LEVEL=info
```

**部署**:
```bash
docker-compose build
docker-compose up -d
docker-compose logs -f
```

#### 方案 C: Kubernetes 部署

**Deployment** (`p2p-deployment.yaml`):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: p2p-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: p2p
  template:
    metadata:
      labels:
        app: p2p
    spec:
      containers:
      - name: p2p-server
        image: your-registry/p2p-server:latest
        ports:
        - containerPort: 4001
        - containerPort: 8000
        env:
        - name: P2P_LOG_LEVEL
          value: "info"
        volumeMounts:
        - name: storage
          mountPath: /app/files
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: p2p-storage
```

### 4.4 配置优先级

**优先级**（从高到低）:
```
1. 命令行参数
   ↓
2. 环境变量 (P2P_*)
   ↓
3. 配置文件
   ↓
4. 代码默认值
```

### 4.5 环境变量列表

| 环境变量 | 对应配置项 | 示例值 |
|---------|-----------|--------|
| `P2P_PORT` | network.port | `8000` |
| `P2P_INSECURE` | network.insecure | `true` |
| `P2P_CHUNK_PATH` | storage.chunk_path | `/data/chunks` |
| `P2P_MAX_CONCURRENCY` | performance.max_concurrency | `16` |
| `P2P_LOG_LEVEL` | logging.level | `info` |

---

## 5. 二次开发指南

### 5.1 开发准备

#### 1. 环境搭建

```bash
# 安装 Go 1.23+
# 下载: https://golang.org/dl/

# 克隆项目
git clone https://github.com/yourusername/p2pFileTransfer.git
cd p2pFileTransfer

# 下载依赖
go mod download

# 安装开发工具
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install golang.org/x/tools/gopls@latest
go install github.com/go-delve/delve/cmd/dlv@latest
```

#### 2. IDE 配置（VS Code）

**.vscode/settings.json**:
```json
{
    "go.useLanguageServer": true,
    "go.lintTool": "golangci-lint",
    "go.lintOnSave": "package",
    "go.formatTool": "goimports",
    "go.buildOnSave": "package"
}
```

### 5.2 修改策略

#### 推荐修改位置

**1. 配置扩展**

```go
// pkg/config/loader.go

// 1. 定义配置结构
type NewFeatureConfig struct {
    Enabled bool   `mapstructure:"enabled"`
    Option  string `mapstructure:"option"`
}

// 2. 添加到 Config
type Config struct {
    // ... 现有字段
    NewFeature NewFeatureConfig `mapstructure:"new_feature"`
}

// 3. 添加验证
func (c *Config) Validate() error {
    // ... 现有验证
    if c.NewFeature.Enabled && c.NewFeature.Option == "" {
        return fmt.Errorf("new_feature.option required")
    }
    return nil
}
```

**2. 自定义节点选择器**

```go
// pkg/p2p/peerSelector.go

type LatencyBasedPeerSelector struct {
    latencyMap map[peer.ID]time.Duration
    mutex      sync.RWMutex
}

func (s *LatencyBasedPeerSelector) SelectPeer(providers []peer.ID) peer.ID {
    s.mutex.RLock()
    defer s.mutex.RUnlock()

    var selected peer.ID
    minLatency := time.Duration(math.MaxInt64)

    for _, provider := range providers {
        if latency, exists := s.latencyMap[provider]; exists {
            if latency < minLatency {
                minLatency = latency
                selected = provider
            }
        }
    }

    return selected
}

// 使用
service.PeerSelector = &LatencyBasedPeerSelector{
    latencyMap: make(map[peer.ID]time.Duration),
}
```

### 5.3 定制化示例

#### 示例1: 添加文件下载进度回调

```go
// pkg/p2p/getFile.go

type ProgressCallback func(current, total int)

func (p *P2PService) DownloadFileWithProgress(
    ctx context.Context,
    metadata *file.MetaData,
    destPath string,
    callback ProgressCallback,
) error {
    for i, chunk := range chunks {
        // 下载 chunk
        downloadChunk(chunk)

        // 调用进度回调
        if callback != nil {
            callback(i+1, len(metadata.Leaves))
        }
    }
    return nil
}
```

#### 示例2: 添加新命令

```go
// cmd/p2p/status.go

var statusCmd = &cobra.Command{
    Use:   "status",
    Short: "Show P2P service status",
    Run: func(cmd *cobra.Command, args []string) {
        // 实现状态查询
        service := getP2PService()
        fmt.Printf("Connected peers: %d\n", len(service.Network().Peers()))
    },
}

func init() {
    rootCmd.AddCommand(statusCmd)
}
```

### 5.4 调试技巧

#### 1. 日志查看

```go
import "github.com/sirupsen/logrus"

logrus.SetLevel(logrus.DebugLevel)

logrus.WithFields(logrus.Fields{
    "peer": peerID,
    "chunk": fmt.Sprintf("%x", chunkHash),
}).Debug("Downloading chunk")
```

#### 2. Delve 调试器

```bash
# 安装
go install github.com/go-delve/delve/cmd/dlv@latest

# 调试程序
dlv debug ./cmd/server -- -config config/config.yaml

# 常用命令
(dlv) break main.main
(dlv) continue
(dlv) print variableName
(dlv) locals
```

#### 3. 性能分析

```bash
# CPU 性能分析
go test -cpuprofile=cpu.prof ./pkg/p2p
go tool pprof cpu.prof

# 内存分析
go test -memprofile=mem.prof ./pkg/p2p
go tool pprof mem.prof
```

### 5.5 测试

```bash
# 运行所有测试
go test ./... -v

# 运行特定测试
go test ./pkg/p2p -v -run TestNewP2PService

# 生成覆盖率报告
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### 5.6 代码质量

```bash
# 代码检查
golangci-lint run

# 格式化代码
goimports -w .

# 使用 go vet
go vet ./...
```

---

## 6. 常见问题与扩展

### 6.1 常见问题

#### Q1: 如何解决"端口已被占用"错误？

**解决方案**:
```bash
# 1. 查找占用端口的进程
lsof -i :8000  # Linux/macOS
netstat -ano | findstr :8000  # Windows

# 2. 终止进程
kill -9 <PID>

# 3. 使用随机端口（推荐）
# config.yaml: port: 0
```

#### Q2: DHT 无法找到其他节点？

**原因**:
- 网络中没有其他节点
- Bootstrap 节点配置错误
- 防火墙阻止了连接

**解决方案**:
```yaml
# 配置 Bootstrap 节点
network:
  bootstrap_peers:
    - /ip4/127.0.0.1/tcp/8001/p2p/QmPeerID1

# 检查防火墙
# Linux: sudo ufw allow 8000/tcp
```

#### Q3: 文件下载很慢？

**解决方案**:
```yaml
# 增加并发数
performance:
  max_concurrency: 32  # 从 16 增加到 32

# 调整超时
performance:
  request_timeout: 10
  data_timeout: 60
```

#### Q4: 内存占用过高？

**解决方案**:
```go
// 分析内存 profile
curl http://localhost:6060/debug/pprof/heap > heap.prof
go tool pprof heap.prof

// 确保资源释放
defer file.Close()
defer stream.Close()
defer cancel()
```

#### Q5: 如何验证文件完整性？

```go
// 加载元数据
metadata, _ := file.LoadMetadata("metadata/cid.json")

// 下载文件
service.DownloadFile(ctx, metadata, "downloaded.txt")

// 验证根哈希
downloadedHash := computeFileHash("downloaded.txt")
if !bytes.Equal(downloadedHash, metadata.RootHash) {
    log.Fatal("File integrity check failed!")
}
```

### 6.2 性能优化建议

#### 1. 优化并发数

```yaml
performance:
  max_concurrency: 32   # 根据带宽调整
```

**建议值**:
- 家庭网络: 8-16
- 数据中心: 32-64
- 高性能服务器: 64-128

#### 2. 优化超时

```yaml
performance:
  request_timeout: 10    # 慢速网络增加
  data_timeout: 60       # 大文件下载增加
  dht_timeout: 20        # 大型网络增加
```

#### 3. 内存优化

```yaml
storage:
  buffer_number: 32      # 增加缓冲区
```

#### 4. 日志优化

```yaml
logging:
  level: "warn"          # 生产环境使用 warn
  format: "json"         # 便于日志聚合
```

### 6.3 扩展思路

#### 功能扩展

**1. 文件搜索功能**

```go
// 定义文件索引
type FileIndex struct {
    FileName  string
    CID       string
    Keywords  []string
    Size      int64
}

// 发布文件索引
func (p *P2PService) PublishIndex(index FileIndex) error {
    data, _ := json.Marshal(index)
    key := "index:" + index.FileName
    return p.DHT.PutValue(p.Ctx, key, data)
}
```

**2. 文件版本控制**

```go
type FileVersion struct {
    CID       string
    Version   int
    ParentCID string
    Message   string
    Timestamp time.Time
}

type VersionChain struct {
    Current *FileVersion
    History []*FileVersion
}
```

**3. 文件加密存储**

```go
type EncryptionTool interface {
    Encrypt(data []byte, key []byte) ([]byte, error)
    Decrypt(data []byte, key []byte) ([]byte, error)
}

type AESEncryption struct {
    key []byte
}

func (a *AESEncryption) Encrypt(data []byte, key []byte) ([]byte, error) {
    // 实现 AES 加密
}
```

#### 架构扩展

**1. 横向扩展（多节点集群）**

```go
type LoadBalancer struct {
    nodes []*P2PService
    index int
    mu    sync.Mutex
}

func (lb *LoadBalancer) NextNode() *P2PService {
    lb.mu.Lock()
    defer lb.mu.Unlock()

    node := lb.nodes[lb.index]
    lb.index = (lb.index + 1) % len(lb.nodes)
    return node
}
```

**2. 高可用改进**

```go
type HealthChecker struct {
    nodes   map[peer.ID]*P2PService
    health  map[peer.ID]bool
    mu      sync.RWMutex
}

func (hc *HealthChecker) CheckAll() {
    for peerID, node := range hc.nodes {
        healthy := hc.checkNode(node)
        hc.mu.Lock()
        hc.health[peerID] = healthy
        hc.mu.Unlock()

        if !healthy {
            // 触发故障转移
        }
    }
}
```

**3. 集成第三方服务**

**集成 Web3**:
```go
import "github.com/ethereum/go-ethereum/ethclient"

type BlockchainLogger struct {
    client *ethclient.Client
}

func (bl *BlockchainLogger) LogFileUpload(cid string) error {
    // 调用智能合约记录上传
}
```

**集成云存储（S3）**:
```go
import "github.com/aws/aws-sdk-go/service/s3"

type S3Adapter struct {
    client *s3.S3
    bucket string
}

func (sa *S3Adapter) WriteChunk(key string, data []byte) error {
    _, err := sa.client.PutObject(&s3.PutObjectInput{
        Bucket: aws.String(sa.bucket),
        Key:    aws.String(key),
        Body:   bytes.NewReader(data),
    })
    return err
}
```

### 6.4 监控和告警

#### 1. 日志聚合

**使用 ELK**:
```bash
# Filebeat 配置
filebeat.inputs:
- type: log
  paths:
    - /var/log/p2p/*.log
  json.keys_under_root: true

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
```

#### 2. 指标收集

**使用 Prometheus**:
```go
import "github.com/prometheus/client_golang/prometheus"

var (
    downloadCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "p2p_downloads_total",
            Help: "Total number of downloads",
        },
        []string{"status"},
    )
)
```

#### 3. 告警规则

**Prometheus 告警**:
```yaml
groups:
- name: p2p
  rules:
  - alert: P2PServiceDown
    expr: up{job="p2p"} == 0
    for: 5m

  - alert: P2PHighFailureRate
    expr: rate(p2p_downloads_total{status="failed"}[5m]) > 0.1
```

---

## 附录

### A. CLI 命令参考

#### 文件操作

```bash
# 上传文件
p2p file upload <file> [flags]

Flags:
  -t, --tree-type <type>      # Merkle 树类型: chameleon | regular
  -d, --description <text>    # 文件描述
  -o, --output <path>         # 元数据输出路径
  --chunk-size <size>         # 分块大小，字节 (默认: 262144)
  -p, --progress              # 显示进度条

# 查看帮助
p2p file --help
p2p file upload --help
```

#### 服务管理

```bash
# 启动服务
p2p server [flags]

Flags:
  --config <path>            # 配置文件路径
  --port <port>              # 监听端口 (默认: 0 = 随机)
```

#### 其他命令

```bash
p2p version                 # 显示版本信息
p2p help                    # 显示帮助
```

### B. Merkle 树类型选择指南

### Regular Merkle Tree

**使用场景**：
- ✅ 文件备份和归档
- ✅ 一次性文件发布
- ✅ 数据持久化存储
- ✅ 追求最佳性能

**优点**：
- 性能优异
- 实现简单
- 广泛支持

**限制**：
- ❌ 文件内容不可修改

### Chameleon Merkle Tree

**使用场景**：
- ✅ 需要修改已发布的文件
- ✅ 版本控制和可追溯编辑
- ✅ 需要证明编辑权限

**优点**：
- 支持内容修改
- 密钥对控制编辑权限
- 适合动态内容

**注意**：
- ⚠️ 需要妥善保管私钥文件
- ⚠️ 性能略低于 Regular Tree

### C. 相关资源

**GitHub**: [https://github.com/yourusername/p2pFileTransfer](https://github.com/yourusername/p2pFileTransfer)

**文档**:
- [README.md](README.md) - 项目总体介绍
- [CONFIGURATION_GUIDE.md](CONFIGURATION_GUIDE.md) - 完整配置指南
- [06-libp2p库的使用经验.md](06-libp2p库的使用经验.md) - libp2p 详细指南

**组件文档**:
- [组件文档/P2P核心服务组件.md](组件文档/P2P核心服务组件.md)
- [组件文档/Chameleon-Merkle-Tree组件.md](组件文档/Chameleon-Merkle-Tree组件.md)
- [组件文档/配置管理组件.md](组件文档/配置管理组件.md)

**外部资源**：
- [libp2p 文档](https://docs.libp2p.io/)
- [Kademlia DHT 论文](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)
- [Go 最佳实践](https://golang.org/doc/effective_go.html)

---

**文档版本**: v1.0.0
**文档日期**: 2026-01-15

---

