# 配置管理组件

## 组件概述

- **位置**: `pkg/config/loader.go`
- **职责**: 加载、验证和管理配置，支持多源配置（文件、环境变量、默认值）
- **依赖**:
  - `github.com/spf13/viper` - 配置管理框架
  - `github.com/sirupsen/logrus` - 日志
- **被依赖**: `cmd/server/`, `pkg/p2p/`

## 文件结构

```
pkg/config/
└── loader.go    # 配置加载和验证（384 行）
```

## 核心数据结构

### 1. Config（总配置）

```go
type Config struct {
    Network     NetworkConfig     `mapstructure:"network"`
    Storage     StorageConfig     `mapstructure:"storage"`
    Performance PerformanceConfig `mapstructure:"performance"`
    Logging     LoggingConfig     `mapstructure:"logging"`
    AntiLeecher AntiLeecherConfig `mapstructure:"anti_leecher"`
}
```

### 2. NetworkConfig（网络配置）

```go
type NetworkConfig struct {
    Port           int                      `mapstructure:"port"`                      // 监听端口
    Insecure       bool                     `mapstructure:"insecure"`                  // 不安全连接
    Seed           int64                    `mapstructure:"seed"`                      // 随机种子
    BootstrapPeers []string                 `mapstructure:"bootstrap_peers"`           // 引导节点
    ProtocolPrefix string                   `mapstructure:"protocol_prefix"`           // 协议前缀
    AutoRefresh    bool                     `mapstructure:"auto_refresh"`              // 自动刷新
    NameSpace      string                   `mapstructure:"namespace"`                 // DHT命名空间
}
```

### 3. StorageConfig（存储配置）

```go
type StorageConfig struct {
    ChunkPath    string `mapstructure:"chunk_path"`     // Chunk存储路径
    BlockSize    uint   `mapstructure:"block_size"`     // 块大小
    BufferNumber uint   `mapstructure:"buffer_number"`  // 缓冲区数量
}
```

### 4. PerformanceConfig（性能配置）

```go
type PerformanceConfig struct {
    MaxRetries     int `mapstructure:"max_retries"`      // 最大重试次数
    MaxConcurrency int `mapstructure:"max_concurrency"`   // 最大并发数
    RequestTimeout int `mapstructure:"request_timeout"`   // 请求超时
    DataTimeout    int `mapstructure:"data_timeout"`      // 数据超时
    DHTTimeout     int `mapstructure:"dht_timeout"`       // DHT超时
}
```

### 5. LoggingConfig（日志配置）

```go
type LoggingConfig struct {
    Level  string `mapstructure:"level"`   // 日志级别
    Format string `mapstructure:"format"`  // 日志格式
}
```

### 6. AntiLeecherConfig（反吸血虫配置）

```go
type AntiLeecherConfig struct {
    Enabled        bool    `mapstructure:"enabled"`         // 是否启用
    MinSuccessRate float64 `mapstructure:"min_success_rate"` // 最小成功率
    MinRequests    int     `mapstructure:"min_requests"`     // 最小请求数
}
```

## 核心接口

### 1. Load（加载配置）

```go
func Load(configPath string) (*Config, error)
```

**功能**: 从指定路径加载配置文件

**参数**:
- `configPath`: 配置文件路径（如果为空，自动搜索）

**返回值**:
- `*Config`: 配置对象
- `error`: 错误信息

**示例**:
```go
cfg, err := config.Load("config/config.yaml")
if err != nil {
    log.Fatal(err)
}
```

### 2. GetConfigPath（查找配置文件）

```go
func GetConfigPath(customPath string) string
```

**功能**: 按优先级查找配置文件

**搜索顺序**:
1. 自定义路径
2. `./config.yaml`
3. `./config/config.yaml`
4. `/etc/p2p-file-transfer/config.yaml`

**示例**:
```go
path := config.GetConfigPath("")  // 自动搜索
fmt.Printf("Using config: %s\n", path)
```

### 3. Validate（验证配置）

```go
func (c *Config) Validate() error
```

**功能**: 验证配置的有效性

**验证项**:
- 端口范围: 0-65535
- 块大小: 1KB - 4MB
- 并发数: 1 - 1024
- 超时时间: 1 - 7200 秒
- 成功率阈值: 0.0 - 1.0
- 日志级别: debug, info, warn, error
- 日志格式: json, text

**示例**:
```go
if err := cfg.Validate(); err != nil {
    log.Fatalf("Invalid config: %v", err)
}
```

### 4. EnsureDirectories（创建目录）

```go
func (c *Config) EnsureDirectories() error
```

**功能**: 确保必要的目录存在

**创建的目录**:
- `chunk_path` - Chunk 存储目录

**示例**:
```go
if err := cfg.EnsureDirectories(); err != nil {
    log.Fatalf("Failed to create directories: %v", err)
}
```

### 5. ToP2PConfig（转换为 P2PConfig）

```go
func (c *Config) ToP2PConfig() *p2p.P2PConfig
```

**功能**: 将通用配置转换为 P2P 专用配置

**返回值**:
- `*p2p.P2PConfig`: P2P 配置对象

**示例**:
```go
cfg, _ := config.Load("config.yaml")
p2pConfig := cfg.ToP2PConfig()
service, _ := p2p.NewP2PService(ctx, *p2pConfig)
```

## 核心实现

### 1. 配置加载流程

```go
func Load(configPath string) (*Config, error) {
    // 1. 查找配置文件
    configFile := GetConfigPath(configPath)

    // 2. 创建 viper 实例
    v := viper.New()

    // 3. 设置配置文件路径和类型
    v.SetConfigFile(configFile)
    v.SetConfigType("yaml")

    // 4. 绑定环境变量
    v.SetEnvPrefix("P2P")
    v.AutomaticEnv()

    // 5. 绑定命令行参数
    bindFlags(v)

    // 6. 读取配置文件
    if err := v.ReadInConfig(); err != nil {
        // 配置文件不存在，使用默认值
        logrus.Warnf("Config file not found: %v, using defaults", err)
    }

    // 7. 环境变量覆盖
    loadFromEnv(v)

    // 8. 解析到结构体
    var cfg Config
    if err := v.Unmarshal(&cfg); err != nil {
        return nil, err
    }

    // 9. 验证配置
    if err := cfg.Validate(); err != nil {
        return nil, err
    }

    return &cfg, nil
}
```

### 2. 环境变量绑定

```go
func loadFromEnv(v *viper.Viper) {
    // 网络配置
    if v.IsSet("PORT") {
        v.Set("network.port", v.GetInt("PORT"))
    }
    if v.IsSet("INSECURE") {
        v.Set("network.insecure", v.GetBool("INSECURE"))
    }

    // 存储配置
    if v.IsSet("CHUNK_PATH") {
        v.Set("storage.chunk_path", v.GetString("CHUNK_PATH"))
    }

    // 性能配置
    if v.IsSet("MAX_CONCURRENCY") {
        v.Set("performance.max_concurrency", v.GetInt("MAX_CONCURRENCY"))
    }

    // 日志配置
    if v.IsSet("LOG_LEVEL") {
        v.Set("logging.level", v.GetString("LOG_LEVEL"))
    }

    // ... 更多环境变量绑定
}
```

### 3. 配置验证

```go
func (c *Config) Validate() error {
    // 验证网络配置
    if c.Network.Port < 0 || c.Network.Port > 65535 {
        return fmt.Errorf("invalid port: %d (must be 0-65535)", c.Network.Port)
    }

    // 验证存储配置
    if c.Storage.BlockSize < 1024 || c.Storage.BlockSize > 4*1024*1024 {
        return fmt.Errorf("invalid block_size: %d (must be 1KB-4MB)", c.Storage.BlockSize)
    }

    // 验证性能配置
    if c.Performance.MaxConcurrency < 1 || c.Performance.MaxConcurrency > 1024 {
        return fmt.Errorf("invalid max_concurrency: %d (must be 1-1024)", c.Performance.MaxConcurrency)
    }

    // 验证超时配置
    if c.Performance.RequestTimeout < 1 || c.Performance.RequestTimeout > 7200 {
        return fmt.Errorf("invalid request_timeout: %d (must be 1-7200)", c.Performance.RequestTimeout)
    }

    // 验证日志配置
    validLogLevels := map[string]bool{
        "debug": true,
        "info":  true,
        "warn":  true,
        "error": true,
    }
    if !validLogLevels[c.Logging.Level] {
        return fmt.Errorf("invalid log level: %s (must be debug, info, warn, or error)", c.Logging.Level)
    }

    // 验证日志格式
    validFormats := map[string]bool{
        "json": true,
        "text": true,
    }
    if !validFormats[c.Logging.Format] {
        return fmt.Errorf("invalid log format: %s (must be json or text)", c.Logging.Format)
    }

    // 验证反吸血虫配置
    if c.AntiLeecher.MinSuccessRate < 0.0 || c.AntiLeecher.MinSuccessRate > 1.0 {
        return fmt.Errorf("invalid min_success_rate: %.2f (must be 0.0-1.0)", c.AntiLeecher.MinSuccessRate)
    }

    return nil
}
```

### 4. 目录创建

```go
func (c *Config) EnsureDirectories() error {
    // 创建 Chunk 存储目录
    if err := os.MkdirAll(c.Storage.ChunkPath, 0755); err != nil {
        return fmt.Errorf("failed to create chunk directory: %w", err)
    }

    // 创建元数据目录
    metadataPath := filepath.Dir(c.Storage.ChunkPath)
    metadataPath = filepath.Join(metadataPath, "metadata")
    if err := os.MkdirAll(metadataPath, 0755); err != nil {
        return fmt.Errorf("failed to create metadata directory: %w", err)
    }

    logrus.Infof("Created directories: %s, %s", c.Storage.ChunkPath, metadataPath)
    return nil
}
```

### 5. 配置转换

```go
func (c *Config) ToP2PConfig() *p2p.P2PConfig {
    return &p2p.P2PConfig{
        Port:              c.Network.Port,
        Insecure:          c.Network.Insecure,
        Seed:              c.Network.Seed,
        ProtocolPrefix:    c.Network.ProtocolPrefix,
        EnableAutoRefresh: c.Network.AutoRefresh,
        NameSpace:         c.Network.NameSpace,
        ChunkStoragePath:  c.Storage.ChunkPath,
        MaxRetries:        c.Performance.MaxRetries,
        MaxConcurrency:    c.Performance.MaxConcurrency,
        RequestTimeout:    c.Performance.RequestTimeout,
        DataTimeout:       c.Performance.DataTimeout,
        DHTTimeout:        c.Performance.DHTTimeout,
    }
}
```

## 配置文件示例

### 完整配置文件

```yaml
# config/config.yaml

network:
  port: 0                         # 0 = 随机端口
  insecure: false                 # 生产环境必须为 false
  seed: 0                         # 随机种子
  bootstrap_peers:                # 引导节点（可选）
    - /ip4/127.0.0.1/tcp/8001/p2p/QmPeerID1
    - /ip4/127.0.0.1/tcp/8002/p2p/QmPeerID2
  protocol_prefix: "/p2p-file-transfer"
  auto_refresh: true
  namespace: "p2p-file-transfer"

storage:
  chunk_path: "files"             # Chunk 存储路径
  block_size: 262144              # 256KB
  buffer_number: 16               # 缓冲区数量

performance:
  max_retries: 3                  # 最大重试次数
  max_concurrency: 16             # 最大并发数
  request_timeout: 5              # 请求超时（秒）
  data_timeout: 30                # 数据传输超时（秒）
  dht_timeout: 10                 # DHT 操作超时（秒）

logging:
  level: "info"                   # 日志级别
  format: "text"                  # 日志格式

anti_leecher:
  enabled: true                   # 启用反吸血虫
  min_success_rate: 0.5           # 最小成功率（50%）
  min_requests: 10                # 最小请求数
```

## 环境变量映射

| 环境变量 | 配置路径 | 示例值 |
|---------|----------|--------|
| `P2P_PORT` | network.port | `8000` |
| `P2P_INSECURE` | network.insecure | `true` |
| `P2P_SEED` | network.seed | `12345` |
| `P2P_BOOTSTRAP_PEERS` | network.bootstrap_peers | `/ip4/...,...` |
| `P2P_PROTOCOL_PREFIX` | network.protocol_prefix | `/p2p` |
| `P2P_NAMESPACE` | network.namespace | `p2p` |
| `P2P_CHUNK_PATH` | storage.chunk_path | `/data/chunks` |
| `P2P_BLOCK_SIZE` | storage.block_size | `262144` |
| `P2P_BUFFER_NUMBER` | storage.buffer_number | `16` |
| `P2P_MAX_RETRIES` | performance.max_retries | `3` |
| `P2P_MAX_CONCURRENCY` | performance.max_concurrency | `16` |
| `P2P_REQUEST_TIMEOUT` | performance.request_timeout | `5` |
| `P2P_DATA_TIMEOUT` | performance.data_timeout | `30` |
| `P2P_DHT_TIMEOUT` | performance.dht_timeout | `10` |
| `P2P_LOG_LEVEL` | logging.level | `info` |
| `P2P_LOG_FORMAT` | logging.format | `json` |
| `P2P_ANTI_LEECHER_ENABLED` | anti_leecher.enabled | `true` |
| `P2P_MIN_SUCCESS_RATE` | anti_leecher.min_success_rate | `0.5` |
| `P2P_MIN_REQUESTS` | anti_leecher.min_requests | `10` |

## 测试用例

```go
func TestLoadConfig(t *testing.T) {
    // 测试加载配置文件
    cfg, err := config.Load("config/config.example.yaml")
    assert.NoError(t, err)
    assert.NotNil(t, cfg)

    // 验证默认值
    assert.Equal(t, 0, cfg.Network.Port)
    assert.Equal(t, false, cfg.Network.Insecure)
    assert.Equal(t, "files", cfg.Storage.ChunkPath)
    assert.Equal(t, 16, cfg.Performance.MaxConcurrency)
}

func TestValidateConfig(t *testing.T) {
    // 测试有效配置
    cfg := &config.Config{
        Network: config.NetworkConfig{
            Port:     8000,
            Insecure: false,
        },
        Performance: config.PerformanceConfig{
            MaxConcurrency: 16,
        },
        Logging: config.LoggingConfig{
            Level:  "info",
            Format: "text",
        },
    }

    err := cfg.Validate()
    assert.NoError(t, err)

    // 测试无效配置
    cfg.Network.Port = 70000  // 超出范围
    err = cfg.Validate()
    assert.Error(t, err)
}

func TestToP2PConfig(t *testing.T) {
    cfg := &config.Config{
        Network: config.NetworkConfig{
            Port:    8000,
            Insecure: false,
        },
        Storage: config.StorageConfig{
            ChunkPath: "files",
        },
        Performance: config.PerformanceConfig{
            MaxConcurrency: 16,
        },
    }

    p2pConfig := cfg.ToP2PConfig()

    assert.Equal(t, 8000, p2pConfig.Port)
    assert.Equal(t, false, p2pConfig.Insecure)
    assert.Equal(t, "files", p2pConfig.ChunkStoragePath)
    assert.Equal(t, 16, p2pConfig.MaxConcurrency)
}
```

## 扩展点

### 1. 添加新配置项

```go
// 1. 在 Config 结构体中添加字段
type Config struct {
    // ... 现有字段
    CustomFeature CustomConfig `mapstructure:"custom_feature"`
}

// 2. 定义新配置结构
type CustomConfig struct {
    Enabled bool   `mapstructure:"enabled"`
    Option  string `mapstructure:"option"`
}

// 3. 在 Validate 中添加验证
func (c *Config) Validate() error {
    // ... 现有验证

    if c.CustomFeature.Enabled && c.CustomFeature.Option == "" {
        return fmt.Errorf("custom_feature.option is required when enabled")
    }

    return nil
}

// 4. 添加环境变量绑定
func loadFromEnv(v *viper.Viper) {
    // ... 现有绑定

    if v.IsSet("CUSTOM_ENABLED") {
        v.Set("custom_feature.enabled", v.GetBool("CUSTOM_ENABLED"))
    }
}
```

### 2. 支持其他配置格式

```go
// 当前支持 YAML，扩展支持 JSON、TOML 等
func Load(configPath string) (*Config, error) {
    v := viper.New()

    // 根据文件扩展名确定格式
    ext := filepath.Ext(configPath)
    switch ext {
    case ".yaml", ".yml":
        v.SetConfigType("yaml")
    case ".json":
        v.SetConfigType("json")
    case ".toml":
        v.SetConfigType("toml")
    default:
        v.SetConfigType("yaml")  // 默认
    }

    // ... 其余代码
}
```

### 3. 配置热重载

```go
func WatchConfig(configPath string, callback func(*Config)) error {
    v := viper.New()

    // 初始加载
    cfg, err := Load(configPath)
    if err != nil {
        return err
    }

    // 监控文件变化
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return err
    }

    go func() {
        for {
            select {
            case event := <-watcher.Events:
                if event.Op&fsnotify.Write == fsnotify.Write {
                    // 重新加载配置
                    newCfg, err := Load(configPath)
                    if err == nil {
                        callback(newCfg)
                    }
                }
            }
        }
    }()

    return watcher.Add(configPath)
}
```

## 最佳实践

1. **配置管理**
   - ✅ 使用版本控制管理 `config.example.yaml`
   - ✅ 将 `config.yaml` 添加到 `.gitignore`
   - ✅ 为不同环境创建不同配置文件
   - ✅ 敏感信息使用环境变量

2. **配置验证**
   - ✅ 启动时验证所有配置
   - ✅ 提供清晰的错误提示
   - ✅ 设置合理的默认值

3. **文档化**
   - ✅ 在 `config.example.yaml` 中添加注释
   - ✅ 提供配置文档
   - ✅ 说明每个配置项的影响

---

**相关文档**:
- [P2P 核心服务组件](P2P核心服务组件.md)
- [03-配置与部署指南.md](../03-配置与部署指南.md)
